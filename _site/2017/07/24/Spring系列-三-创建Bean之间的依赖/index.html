<!DOCTYPE html>
<html>

  <head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Spring系列（三）—— 创建Bean之间的依赖 - 起飞的凤凰</title>

	<link rel="shortcut icon" href="/styles/images/favicon.jpg">
	<link rel="icon" href="/styles/images/favicon.jpg">

	<link rel="stylesheet" href="/styles/css/index.css">
	<link rel="stylesheet" href="/styles/css/fontawesome/css/font-awesome.min.css">
	<link rel="stylesheet" href="/styles/css/syntax.css">
	<link rel="canonical" href="/2017/07/24/Spring%E7%B3%BB%E5%88%97-%E4%B8%89-%E5%88%9B%E5%BB%BABean%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BE%9D%E8%B5%96/">
	<link rel="alternate" type="application/rss+xml" title="起飞的凤凰" href="/feed.xml">
	
	<meta name="keywords" content="Spring系列（三）—— 创建Bean之间的依赖, 起飞的凤凰, 王成;个人博客;学而不思则罔;思而不学则殆;生命不止;折腾不休">
	<meta name="description" content="王成;个人博客;学而不思则罔;思而不学则殆;生命不止;折腾不休">

	<script src="/styles/js/jquery.min.js"></script>
	<!--[if lt IE 9]>
    	<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  	<![endif]-->
  	<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?94be4b0f9fc5d94cc0d0415ea6761ae9";
		  var s = document.getElementsByTagName("script")[0]; 
		  s.parentNode.insertBefore(hm, s);
		})();
	</script>
  	<style type="text/css">
	  	.docs-content{
	  		margin-bottom: 10px;
	  	}
  	</style>
</head>

  <body class="index">

    <header class="navbar navbar-inverse navbar-fixed-top docs-nav" role="banner">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a href="/" class="navbar-brand">
        <img src="/styles/images/logo.jpg">
      </a>
    </div>
    <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
      <ul class="nav navbar-nav">    
        <li>
          <a href="/">主页</a>
        </li>
        <li>
          <a href="/categories/">大类</a>
        </li>
        <li>
          <a href="/tag">小类</a>
        </li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
            <a><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span></a>
        </li>
        <li>
          <a href="/donate/"><strong>打赏</strong></a>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown">关于<b class="caret"></b></a>
          <ul class="dropdown-menu">
            <li><a rel="nofollow" target="_blank" href="https://github.com/stormphoenix/">Github</a></li>
            <li><a rel="nofollow" target="_blank" href="http://github.com/stormphoenix/">关于作者</a></li>
            <li><a rel="nofollow" href="/books">我的书单</a></li>
			<!--            <li><a rel="nofollow" href="http://www.hifreud.com/domains/">域名管理</a></li> -->
            <li><a rel="nofollow" href="/reference">推荐博客</a></li>
            <li><a href="/feed.xml">RSS订阅</a></li>
            <li class="divider"></li>
            <li><a rel="nofollow" target="_blank" href="https://github.com/stormphoenix/stormphoenix.github.io/">本项目</a></li>
          </ul>
        </li>
      </ul>
    </nav>
  </div>
</header>

    <div class="docs-header" id="content">
  <div class="container">
  	
  		<!--
		    <h1>Spring系列（三）—— 创建Bean之间的依赖</h1>
		    <p>Post on Jul 24, 2017 by <a href="/about">起飞的凤凰</a></p>
		-->
		    <h1>为了生命中的美好，不妥协直到变老.</h1>
    
  </div>
</div>
    
      
<div class="banner">
  <div class="container">
  	
    	<a href="/categories/#Spring-ref">Spring</a>	/
    	<a href="/tag/#-ref"></a>
    
  </div>
</div>

    

    <div class="container docs-container">
  <div class="row">
    <div class="col-md-3">
      <div class="sidebar hidden-print" role="complementary">
        <div id="navigation">
  <h1>目录</h1>
  <ul class="nav sidenav">
<!--
    
      
      
      
      

      
        <li><a href="#year_2017">2017</a>
          <ul class="nav">
            <li><a href="#month_2017_July">July</a></li>
      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
              <li><a href="#month_2017_June">June</a></li>
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            </ul>
          </li>
      
    
-->
  </ul>
</div> 
      </div>
    </div>
    <div class="col-md-9" role="main">
      <div class="panel docs-content">
        <div class="wrapper">
            <header class="post-header">
              <h1 class="post-title">Spring系列（三）—— 创建Bean之间的依赖</h1>
              <!--
                <p class="post-meta">Jul 24, 2017</p>
              -->
              <div class="meta">Posted on <span class="postdate">Jul 24, 2017</span> By <a target="_blank" href="http://localhost:4000">起飞的凤凰</a></div>
              <br />
            </header>
            <article class="post-content">
              <ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">前言</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">预备知识</a></li>
  <li><a href="#springbean" id="markdown-toc-springbean">利用Spring配置Bean之间的依赖</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">混合配置</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">一些注意事项</a></li>
</ul>

<h1 id="section">前言</h1>

<p>在面向对象程序设计中，程序是由一个个的对象组成的，不同的对象负责不同的工作。程序要实现某一个功能，通常是由多个对象协同工作来实现的。</p>

<p>对象和对象之间的协同，意味着对象和对象之间的依赖。这一点可以参考之前写的<a href="https://stormphoenix.github.io/2017/06/24/Spring系列-一-初识Spring/">博客</a>。</p>

<p>所谓的Java Bean，我简单的理解成Java对象。创建对象之间的依赖就是创建Bean之间的依赖。</p>

<p>下面举一个例子讲解一下。</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">public class Foo {
	private Boo boo;
}</code></pre></figure>

<p>这个例子里面，类Foo的属性boo引用了类Boo，这就是Foo依赖于Boo。</p>

<p>那么问题在于，Foo如何初始化这个Boo呢？</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">// 实现1
public class Foo {
	...
	public Foo() {
		this.boo = new Boo();
	}
	...
}

// 实现2
public class Foo {
	...
	public Foo(Boo boo) {
		this.boo = boo;
	}
	...
}

// 实现3
public class Foo {
	...
	public void setBoo(Boo boo) {
		this.boo = boo;
	}
	...
}</code></pre></figure>

<p>实现一有如下两个问题：
* 创建Boo对象不是Foo应该负责的功能。（违反了单一职责原则，一个类只要专注于实现自己的功能就好了，不要管其他。在这里，Foo的并不负责如何创建Boo对象）
* 假设由于某种原因，导致Boo的构造函数变化了，那么Foo对象也要跟着变化。（变化的和不变化的要分开，在这里，Boo的构造函数是可能会变化的，但Foo对Boo的依赖形式是不变的，所以Foo是不能靠创建Boo来实现对Boo对象的依赖）</p>

<p>实现二和实现三则避免了上述问题。那么麻烦的地方在于，在哪里调用这个Foo构造器或者setter方法？当然，可以通过工厂的方法将Boo注入。不过在这里，当然是用Spring。</p>

<h1 id="section-1">预备知识</h1>

<ul>
  <li>Component。意思是<code>组件</code>，一个简单的概念。可以认为一个Bean就是一个组件。建立对象之间的依赖关系可以理解为将 Bean 和 Bean 组装在一起。</li>
  <li>Autowire。自动装配。Spring的自动装配功能，可以自动将不同的Component组装在一起，构成组件和组件之间的依赖。</li>
  <li>阅读过<a href="https://stormphoenix.github.io/2017/06/25/Spring系列-二-Spring内部实现的简单理解">Spring 系列（二）</a></li>
</ul>

<h1 id="springbean">利用Spring配置Bean之间的依赖</h1>

<p>先看一个很简单的例子：</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">/**
* 车辆
*/ 
public interface Car {
	void drive();
}

/**
* 车轮
*/
public interface Wheel {
	void role();
}

/**
* 橡胶轮胎，Wheel 的一个实现
*/
public class RubberWheel implements Wheel {
	void role() {
		// do something 
	}
}

/**
* 奔驰车， Car 接口的一个实现
*/
public class Bench implements Car {
	private Wheel wheel;

	void drive() {
		wheel.role();
	}
}</code></pre></figure>

<p>这里 Bench Bean依赖于 Wheel，所以 Wheel 是要被注入到 Bench 的。在第一篇<a href="https://stormphoenix.github.io/2017/06/24/Spring系列-一-初识Spring/">博客</a>中提到了 Spring 可以帮我们做<code>注入</code>这件事情，那就用这个例子来说明 Spring 是怎么做的吧。</p>

<p>创建Bean之间依赖的方式分为两大类：Java方式；XML配置文件方式。其中Java方式又划分成两种：Java注解方式；Java代码方式。依次讲解。</p>

<ul>
  <li><strong>Java注解方式</strong>
思路：这种方式是和<code>自动扫描</code>功能搭配起来的。首先<code>Spring容器</code>会加载<code>Spring 配置类</code>，然后发现<code>Spring 配置类</code>设置成自动扫描模式，于是<code>Spring 容器</code>会自动扫描配置类所在的整个包里面的Java类，查看是否有Java类被加上了<code>@Component</code>注解，如果加上了，就认为这个类是<code>Spring 容器</code>中的一个组件，然后把这个组件初始化。在初始化这个组件的过程中，如果发现有属性字段被<code>@Autowire</code>注解修饰，就认为这个字段是这个组件依赖的另外一个组件，就在<code>Spring 容器</code>中查找是否以及初始化了这个被依赖的组件，如果初始化了，就把这个组件赋值给<code>@Autowire</code>修饰的字段。从而实现了 Spring 的依赖注入功能。下面利用例子来解释。(<code>Spring容器</code>这个概念可以参考<a href="https://stormphoenix.github.io/2017/06/25/Spring系列-二-Spring内部实现的简单理解">Spring 系列（二）</a>)</li>
</ul>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">/**
* 车辆
*/ 
public interface Car {
	void drive();
}

/**
* 车轮
*/
public interface Wheel {
	void role();
}

/**
* 橡胶轮胎，Wheel 的一个实现
*
* 这里用了 @Component 注解，代表 RubberWheel 是 Spring 容器中的
* 一个 Bean 。Spring 容器在自动扫描的时候会自动初始化这个 Bean 。
*/
@Component
public class RubberWheel implements Wheel {
	void role() {
		System.out.println(&quot;RubberWheel is rolling&quot;)
	}
}

/**
* 奔驰车， Car 接口的一个实现
*
* 同 Wheel 的用法。
*/
@Component
public class Bench implements Car {
    /**
    * Spring 发现 wheel 字段被 @Autowire 修饰，就会从 Spring 容器
    * 中查找是否有实例化了 Wheel 这个 Bean。如果有，那么这个 Wheel 
    * 就会被赋值到这个字段。
    * 
    * 在这个例子中， Wheel 的实现只有 RubberWheel 这个类，并且这个
    * 类被 @Component 所修饰，所以 RubberWheel 的实例会被赋值给这
    * 个字段。
    */ 
    @Autowire
	private Wheel wheel;

	void drive() {
		wheel.role();
	}
}

/**
* 之前提到的配置类。
*
* @Configurable 。被这个类修饰表明这个类是一个配置类，Spring 会从这
* 个类中加载需要的信息。
*
* @ComponentScan 。一个 Java 配置类如果有这个注解修饰，表明 Spring
* 不需要从这个配置类中加载信息，而是自己扫描这个配置类所在的整个包来搜
* 寻信息。如果之前的 Bench 类和 RubberWheel 类与 JavaConfig 同处
* 于一个包下，那么这两个类就会被 Spring 实例化。
*/
@Configurable
@ComponentScan
public class JavaConfig {
}

public class Main {
    public static void main(String[] args) {
        // 创建 Spring 容器，并加载 JavaConfig 配置类
        // 这个 ApplicationContext 就是 Spring 容器，
        // 而 AnnotationConfigApplicationContext 是
        // 它的一种实现，用于加载 Java配置类
		ApplicationContext context = new AnnotationConfigApplicationContext(JavaConfig.class);
		// 等上面的代码执行完毕，那么 RubberWheel 和 Bench 两个类就
		// 被实例化了。下面通过 Spring 容器来获取，实例化的这两个类。

        // 获取奔驰车
        // 这里的疑问就是，传入的参数是 Car.class 对象，为什么获得
        // 的是 Bench 类型的对象。原因是 Bench 是 Car 实现，并且
        // 是唯一的一个实现。如果 Car 有多个实现，并且都被 Spring 
        // 容器初始化，那么这段代码就会抛出异常，因为 Spring 不知道
        // 要返回哪一个实现。
        Bench benchCar = context.getBean(Car.class);
        // 调用方法
        benchCar.drive();
    }
}</code></pre></figure>

<p>所有的说明已经写入了代码注释之中。</p>

<ul>
  <li><strong>Java代码方式</strong>
Java注解方式 … … 不也是 Java代码么 … …，而且 Java代码方式也用到了注解，不过两者还是有区别的，区别在于自动扫描 : )
思路：依然是 <code>Spring 容器</code>加载 <code>Java 配置类</code>，不过此时 <code>Java配置类</code>没有被设置成自动扫描，所有的信息都要从这个配置类中获取。一个类是否属于<code>Spring 容器</code>、是否需要初始化完全由配置类决定 … … 所以，<code>@Component</code>注解在这种方式下是没有作用的。其他的地方和<code>Java注解方式</code>一样。</li>
</ul>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">/**
* 车辆
*/ 
public interface Car {
	void drive();
}

/**
* 车轮
*/
public interface Wheel {
	void role();
}

/**
* 橡胶轮胎，Wheel 的一个实现
*
* 这里去掉了 @Component 注解。也就意味着 RubberWheel 是否是
* Spring 容器中的组件完全由Java配置类中的信息决定。
*/
public class RubberWheel implements Wheel {
	void role() {
		System.out.println(&quot;RubberWheel is rolling&quot;)
	}
}

/**
* 奔驰车， Car 接口的一个实现
*
* 同 Wheel 的用法。
*/
public class Bench implements Car {
    /**
    * Spring 发现 wheel 字段被 @Autowire 修饰，就会从 Spring 容器
    * 中查找是否有实例化了 Wheel 这个 Bean。如果有，那么这个 Wheel 
    * 就会被赋值到这个字段。
    * 
    * 在这个例子中， Wheel 的实现只有 RubberWheel 这个类，并且这个
    * 类被 @Component 所修饰，所以 RubberWheel 的实例会被赋值给这
    * 个字段。
    */ 
    @Autowire
	private Wheel wheel;

	void drive() {
		wheel.role();
	}
}

/**
*
* @Configurable 。被这个类修饰表明这个类是一个配置类，Spring 会从这
* 个类中加载需要的信息。
*/
@Configurable
public class JavaConfig {
    /**
    * 当一个方法被 @Bean 修饰的时候，它的返回值就会作为
    * Spring 容器中的一个组件。所以说 @Bean 实现的效果
    * 和用 @Component 注解实现是一样。 不过他们还是有区别
	*
	* 用 @Component 修饰的类是由 Spring 容器初始化的，而
	* 初始化参数默认是无参数，也就意味着用 Java注解方式实例
	* 化的类的构造函数是无参数的。
    *
    * 很明显，如果用 @Bean ，那么具体的构造方式是由自己确定
    * 的... ...虽然这个地方也是使用无参数的构造方法 :)
    */
    @Bean
	public Car getCar() {
		return new Bench();
	}

	@Bean
	public Wheel getWheel() {
		return new RubberWheel();
	}
}

public class Main {
    public static void main(String[] args) {
	    // 同上
		ApplicationContext context = new AnnotationConfigApplicationContext(JavaConfig.class);
        // 同上
        Bench benchCar = context.getBean(Car.class);
        // 调用方法
        benchCar.drive();
    }
}</code></pre></figure>

<p>详细说明见注释</p>

<ul>
  <li><strong>XML配置方式</strong></li>
</ul>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!-- 这里实例化一个 RubberWheel， 这里 rubberWheel 是它的id，用来被其他位置引用 --&gt;
    &lt;bean id=&quot;rubberWheel&quot; class=&quot;com.stormphoenix.demo.RubberWheel&quot;/&gt;

    &lt;!-- 实例化奔驰车，这里的属性wheel是bench的字段名字，引用了 rubberWheel id，效果就是把RubberWheel注入到这个类 --&gt;
    &lt;bean id=&quot;bench&quot; class=&quot;com.stormphoenix.demo.Bench&quot;&gt;
        &lt;property name=&quot;wheel&quot; ref=&quot;rubberWheel&quot;&gt;
    &lt;/bean&gt;
&lt;/bean&gt;

// 导入的步骤和之前的 Main 一样，不同之处在于 Spring容器，XML配置采
// 用的是ClassPathXmlApplicationContext</code></pre></figure>

<h1 id="section-2">混合配置</h1>
<p>不同人的对配置方式的偏好不一样，所以一个项目中几种不同的配置方式共存是很正常的。同时，一个配置类或者XML配置文件如果包含的内容太多，就需要拆分成好几个配置项目，否则就显得臃肿。</p>

<p>也就意味着，一个项目有好几种配置方式，一种配置方式有好几个配置类或配置文件。如果存在这样的情况，就需要把不同的配置合并成一个，方便 Spring容器加载。如果不合并的化，那么 Spring 容器一个一个加载是很麻烦的。</p>

<p>下面简单说明。</p>

<ul>
  <li>Java配置与XML配置合并
在 Java 配置类里面，利用 @ImportResource 注解导入 XML 配置</li>
</ul>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">/**
* @ImportResource 里面的值的固定格式是
* classpath:xxx.xml，其中xxx就是XML配置
* 文件的名称。
* 
* 导入后，JavaConfig中的信息就和XML配置文件
* 中的信息合并了。只要 Spring容器加载了 JavaConfig
* 配置类，就自然而然的加载了 XML配置文件的信息。
*/
@Configurable
@ImportResource(&quot;classpath:xxx.xml&quot;)
public class JavaConfig {
	// do something
}</code></pre></figure>

<ul>
  <li>Java配置类和Java配置类合并
利用 @Import 导入另外一个配置类</li>
</ul>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">/**
* OtherConfig.class 是另外一个配置类，可以在任何包路径下，
* 其他的同上。
*/
@Configurable
@Import(OtherConfig.class)
public class JavaConfig {
	// do something
}</code></pre></figure>

<ul>
  <li>XML配置文件与Java配置类合并</li>
</ul>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">&lt;!-- XXX 是 Java配置类的名称 --&gt;
&lt;!-- 当 ClassPathXmlApplicationContext 容器加载了XML文件时，XXX配置类中的信息也一样会被加载。 --&gt;
&lt;bean class=&quot;XXX&quot; /&gt;</code></pre></figure>

<ul>
  <li>XML配置文件与XML配置文件合并</li>
</ul>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">&lt;!-- 道理同上 --&gt;
&lt;import resource=&quot;xxx.xml&quot; /&gt;</code></pre></figure>

<h1 id="section-3">一些注意事项</h1>
<p>时间有限，不可能讲把具体细节讲的面面俱到，所以这个博客只记录原理性的东西。所以要真正的使用这个框架，看博客坑定不够，必须看相关书籍。</p>

<p>下面记录一些额外的知识点。</p>

<ul>
  <li>Java注解方式中的自动扫描，其默认扫描的地方是配置类所在的包。不过这个地方可以自己配置。可以看源码注释。下面列举几种：</li>
</ul>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">// 指定多个包路径
@ComponentScan(basePackages = {&quot;xxx&quot;, &quot;yyy&quot;})

// 制定多个类，扫描类所在的包
@ComponentScan(basePackageClasses = {&quot;XXX.class&quot;, &quot;YYY.class&quot;})</code></pre></figure>

<ul>
  <li>
    <p>XML配置文件功能没有讲全，其实还有很多标签用来配置bean的细节。</p>
  </li>
  <li>
    <p>@Autowire 不仅仅可以添加在属性字段上，还可以添加到SETTER方法、构造方法上。</p>
  </li>
  <li>
    <p>@Bean 注解可以给 Bean 设置ID</p>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">// 返回的 bean 的 id 是 beanId
@Bean(&quot;beanId&quot;)
// an method</code></pre></figure>

<ul>
  <li>@Bean 注解的方法返回的 Bean 默认情况下是单例。</li>
</ul>


            </article>
        </div>
      </div>
      <div class="panel docs-content">
        <article class="post-content">
          <div class="wrapper">
            


  <div id="disqus_thread"></div>
<script>

/**
  *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
  *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
   var disqus_config = function () {
   this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
   this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
   };
   */
(function() { // DON'T EDIT BELOW THIS LINE
 var d = document, s = d.createElement('script');
 s.src = 'https://stormphoenixde-bo-ke.disqus.com/embed.js';
 s.setAttribute('data-timestamp', +new Date());
 (d.head || d.body).appendChild(s);
 })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                




 
          </div>
        </article>
      </div>
    </div>
  </div>
</div>

    
    <footer class="footer" role="contentinfo">
	<div class="container">
		<p class="copyright">Copyright &copy; 2014-2017 <a href="http://github.com/stormphoenix/"><code>起飞的凤凰</code></a>.</p>
		<p>Powered by <a href="http://jekyllrb.com">Jekyll</a>, themed from <a href="http://lesscss.cn/">Less</a>, refactored by <a href="http://www.hifreud.com/">StormPhoenix</a></p>
	</div>
</footer>

<script src="/styles/js/jquery.min.js"></script>
<script src="/styles/js/bootstrap.min.js"></script>
<script src="/styles/js/holder.min.js"></script>
<script src="/styles/js/lessismore.js"></script>
<script src="/styles/js/application.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


  </body>
</html>
