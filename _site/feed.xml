<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description>为了生命中的美好，不妥协直到变老.</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 24 Jul 2017 21:58:15 +0800</pubDate>
    <lastBuildDate>Mon, 24 Jul 2017 21:58:15 +0800</lastBuildDate>
    <generator>Jekyll v3.5.0</generator>
    
      <item>
        <title>Spring系列（三）—— 创建Bean之间的依赖</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;预备知识&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#springbean&quot; id=&quot;markdown-toc-springbean&quot;&gt;利用Spring配置Bean之间的依赖&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;混合配置&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;一些注意事项&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;在面向对象程序设计中，程序是由一个个的对象组成的，不同的对象负责不同的工作。程序要实现某一个功能，通常是由多个对象协同工作来实现的。&lt;/p&gt;

&lt;p&gt;对象和对象之间的协同，意味着对象和对象之间的依赖。这一点可以参考之前写的&lt;a href=&quot;https://stormphoenix.github.io/2017/06/24/Spring系列-一-初识Spring/&quot;&gt;博客&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;所谓的Java Bean，我简单的理解成Java对象。创建对象之间的依赖就是创建Bean之间的依赖。&lt;/p&gt;

&lt;p&gt;下面举一个例子讲解一下。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;public class Foo {
	private Boo boo;
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;这个例子里面，类Foo的属性boo引用了类Boo，这就是Foo依赖于Boo。&lt;/p&gt;

&lt;p&gt;那么问题在于，Foo如何初始化这个Boo呢？&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;// 实现1
public class Foo {
	...
	public Foo() {
		this.boo = new Boo();
	}
	...
}

// 实现2
public class Foo {
	...
	public Foo(Boo boo) {
		this.boo = boo;
	}
	...
}

// 实现3
public class Foo {
	...
	public void setBoo(Boo boo) {
		this.boo = boo;
	}
	...
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;实现一有如下两个问题：
* 创建Boo对象不是Foo应该负责的功能。（违反了单一职责原则，一个类只要专注于实现自己的功能就好了，不要管其他。在这里，Foo的并不负责如何创建Boo对象）
* 假设由于某种原因，导致Boo的构造函数变化了，那么Foo对象也要跟着变化。（变化的和不变化的要分开，在这里，Boo的构造函数是可能会变化的，但Foo对Boo的依赖形式是不变的，所以Foo是不能靠创建Boo来实现对Boo对象的依赖）&lt;/p&gt;

&lt;p&gt;实现二和实现三则避免了上述问题。那么麻烦的地方在于，在哪里调用这个Foo构造器或者setter方法？当然，可以通过工厂的方法将Boo注入。不过在这里，当然是用Spring。&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;预备知识&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Component。意思是&lt;code&gt;组件&lt;/code&gt;，一个简单的概念。可以认为一个Bean就是一个组件。建立对象之间的依赖关系可以理解为将 Bean 和 Bean 组装在一起。&lt;/li&gt;
  &lt;li&gt;Autowire。自动装配。Spring的自动装配功能，可以自动将不同的Component组装在一起，构成组件和组件之间的依赖。&lt;/li&gt;
  &lt;li&gt;阅读过&lt;a href=&quot;https://stormphoenix.github.io/2017/06/25/Spring系列-二-Spring内部实现的简单理解&quot;&gt;Spring 系列（二）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;springbean&quot;&gt;利用Spring配置Bean之间的依赖&lt;/h1&gt;

&lt;p&gt;先看一个很简单的例子：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;/**
* 车辆
*/ 
public interface Car {
	void drive();
}

/**
* 车轮
*/
public interface Wheel {
	void role();
}

/**
* 橡胶轮胎，Wheel 的一个实现
*/
public class RubberWheel implements Wheel {
	void role() {
		// do something 
	}
}

/**
* 奔驰车， Car 接口的一个实现
*/
public class Bench implements Car {
	private Wheel wheel;

	void drive() {
		wheel.role();
	}
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;这里 Bench Bean依赖于 Wheel，所以 Wheel 是要被注入到 Bench 的。在第一篇&lt;a href=&quot;https://stormphoenix.github.io/2017/06/24/Spring系列-一-初识Spring/&quot;&gt;博客&lt;/a&gt;中提到了 Spring 可以帮我们做&lt;code&gt;注入&lt;/code&gt;这件事情，那就用这个例子来说明 Spring 是怎么做的吧。&lt;/p&gt;

&lt;p&gt;创建Bean之间依赖的方式分为两大类：Java方式；XML配置文件方式。其中Java方式又划分成两种：Java注解方式；Java代码方式。依次讲解。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Java注解方式&lt;/strong&gt;
思路：这种方式是和&lt;code&gt;自动扫描&lt;/code&gt;功能搭配起来的。首先&lt;code&gt;Spring容器&lt;/code&gt;会加载&lt;code&gt;Spring 配置类&lt;/code&gt;，然后发现&lt;code&gt;Spring 配置类&lt;/code&gt;设置成自动扫描模式，于是&lt;code&gt;Spring 容器&lt;/code&gt;会自动扫描配置类所在的整个包里面的Java类，查看是否有Java类被加上了&lt;code&gt;@Component&lt;/code&gt;注解，如果加上了，就认为这个类是&lt;code&gt;Spring 容器&lt;/code&gt;中的一个组件，然后把这个组件初始化。在初始化这个组件的过程中，如果发现有属性字段被&lt;code&gt;@Autowire&lt;/code&gt;注解修饰，就认为这个字段是这个组件依赖的另外一个组件，就在&lt;code&gt;Spring 容器&lt;/code&gt;中查找是否以及初始化了这个被依赖的组件，如果初始化了，就把这个组件赋值给&lt;code&gt;@Autowire&lt;/code&gt;修饰的字段。从而实现了 Spring 的依赖注入功能。下面利用例子来解释。(&lt;code&gt;Spring容器&lt;/code&gt;这个概念可以参考&lt;a href=&quot;https://stormphoenix.github.io/2017/06/25/Spring系列-二-Spring内部实现的简单理解&quot;&gt;Spring 系列（二）&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;/**
* 车辆
*/ 
public interface Car {
	void drive();
}

/**
* 车轮
*/
public interface Wheel {
	void role();
}

/**
* 橡胶轮胎，Wheel 的一个实现
*
* 这里用了 @Component 注解，代表 RubberWheel 是 Spring 容器中的
* 一个 Bean 。Spring 容器在自动扫描的时候会自动初始化这个 Bean 。
*/
@Component
public class RubberWheel implements Wheel {
	void role() {
		System.out.println(&amp;quot;RubberWheel is rolling&amp;quot;)
	}
}

/**
* 奔驰车， Car 接口的一个实现
*
* 同 Wheel 的用法。
*/
@Component
public class Bench implements Car {
    /**
    * Spring 发现 wheel 字段被 @Autowire 修饰，就会从 Spring 容器
    * 中查找是否有实例化了 Wheel 这个 Bean。如果有，那么这个 Wheel 
    * 就会被赋值到这个字段。
    * 
    * 在这个例子中， Wheel 的实现只有 RubberWheel 这个类，并且这个
    * 类被 @Component 所修饰，所以 RubberWheel 的实例会被赋值给这
    * 个字段。
    */ 
    @Autowire
	private Wheel wheel;

	void drive() {
		wheel.role();
	}
}

/**
* 之前提到的配置类。
*
* @Configurable 。被这个类修饰表明这个类是一个配置类，Spring 会从这
* 个类中加载需要的信息。
*
* @ComponentScan 。一个 Java 配置类如果有这个注解修饰，表明 Spring
* 不需要从这个配置类中加载信息，而是自己扫描这个配置类所在的整个包来搜
* 寻信息。如果之前的 Bench 类和 RubberWheel 类与 JavaConfig 同处
* 于一个包下，那么这两个类就会被 Spring 实例化。
*/
@Configurable
@ComponentScan
public class JavaConfig {
}

public class Main {
    public static void main(String[] args) {
        // 创建 Spring 容器，并加载 JavaConfig 配置类
        // 这个 ApplicationContext 就是 Spring 容器，
        // 而 AnnotationConfigApplicationContext 是
        // 它的一种实现，用于加载 Java配置类
		ApplicationContext context = new AnnotationConfigApplicationContext(JavaConfig.class);
		// 等上面的代码执行完毕，那么 RubberWheel 和 Bench 两个类就
		// 被实例化了。下面通过 Spring 容器来获取，实例化的这两个类。

        // 获取奔驰车
        // 这里的疑问就是，传入的参数是 Car.class 对象，为什么获得
        // 的是 Bench 类型的对象。原因是 Bench 是 Car 实现，并且
        // 是唯一的一个实现。如果 Car 有多个实现，并且都被 Spring 
        // 容器初始化，那么这段代码就会抛出异常，因为 Spring 不知道
        // 要返回哪一个实现。
        Bench benchCar = context.getBean(Car.class);
        // 调用方法
        benchCar.drive();
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;所有的说明已经写入了代码注释之中。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Java代码方式&lt;/strong&gt;
Java注解方式 … … 不也是 Java代码么 … …，而且 Java代码方式也用到了注解，不过两者还是有区别的，区别在于自动扫描 : )
思路：依然是 &lt;code&gt;Spring 容器&lt;/code&gt;加载 &lt;code&gt;Java 配置类&lt;/code&gt;，不过此时 &lt;code&gt;Java配置类&lt;/code&gt;没有被设置成自动扫描，所有的信息都要从这个配置类中获取。一个类是否属于&lt;code&gt;Spring 容器&lt;/code&gt;、是否需要初始化完全由配置类决定 … … 所以，&lt;code&gt;@Component&lt;/code&gt;注解在这种方式下是没有作用的。其他的地方和&lt;code&gt;Java注解方式&lt;/code&gt;一样。&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;/**
* 车辆
*/ 
public interface Car {
	void drive();
}

/**
* 车轮
*/
public interface Wheel {
	void role();
}

/**
* 橡胶轮胎，Wheel 的一个实现
*
* 这里去掉了 @Component 注解。也就意味着 RubberWheel 是否是
* Spring 容器中的组件完全由Java配置类中的信息决定。
*/
public class RubberWheel implements Wheel {
	void role() {
		System.out.println(&amp;quot;RubberWheel is rolling&amp;quot;)
	}
}

/**
* 奔驰车， Car 接口的一个实现
*
* 同 Wheel 的用法。
*/
public class Bench implements Car {
    /**
    * Spring 发现 wheel 字段被 @Autowire 修饰，就会从 Spring 容器
    * 中查找是否有实例化了 Wheel 这个 Bean。如果有，那么这个 Wheel 
    * 就会被赋值到这个字段。
    * 
    * 在这个例子中， Wheel 的实现只有 RubberWheel 这个类，并且这个
    * 类被 @Component 所修饰，所以 RubberWheel 的实例会被赋值给这
    * 个字段。
    */ 
    @Autowire
	private Wheel wheel;

	void drive() {
		wheel.role();
	}
}

/**
*
* @Configurable 。被这个类修饰表明这个类是一个配置类，Spring 会从这
* 个类中加载需要的信息。
*/
@Configurable
public class JavaConfig {
    /**
    * 当一个方法被 @Bean 修饰的时候，它的返回值就会作为
    * Spring 容器中的一个组件。所以说 @Bean 实现的效果
    * 和用 @Component 注解实现是一样。 不过他们还是有区别
	*
	* 用 @Component 修饰的类是由 Spring 容器初始化的，而
	* 初始化参数默认是无参数，也就意味着用 Java注解方式实例
	* 化的类的构造函数是无参数的。
    *
    * 很明显，如果用 @Bean ，那么具体的构造方式是由自己确定
    * 的... ...虽然这个地方也是使用无参数的构造方法 :)
    */
    @Bean
	public Car getCar() {
		return new Bench();
	}

	@Bean
	public Wheel getWheel() {
		return new RubberWheel();
	}
}

public class Main {
    public static void main(String[] args) {
	    // 同上
		ApplicationContext context = new AnnotationConfigApplicationContext(JavaConfig.class);
        // 同上
        Bench benchCar = context.getBean(Car.class);
        // 调用方法
        benchCar.drive();
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;详细说明见注释&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;XML配置方式&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&amp;quot;&amp;gt;

    &amp;lt;!-- 这里实例化一个 RubberWheel， 这里 rubberWheel 是它的id，用来被其他位置引用 --&amp;gt;
    &amp;lt;bean id=&amp;quot;rubberWheel&amp;quot; class=&amp;quot;com.stormphoenix.demo.RubberWheel&amp;quot;/&amp;gt;

    &amp;lt;!-- 实例化奔驰车，这里的属性wheel是bench的字段名字，引用了 rubberWheel id，效果就是把RubberWheel注入到这个类 --&amp;gt;
    &amp;lt;bean id=&amp;quot;bench&amp;quot; class=&amp;quot;com.stormphoenix.demo.Bench&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;wheel&amp;quot; ref=&amp;quot;rubberWheel&amp;quot;&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/bean&amp;gt;

// 导入的步骤和之前的 Main 一样，不同之处在于 Spring容器，XML配置采
// 用的是ClassPathXmlApplicationContext&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h1 id=&quot;section-2&quot;&gt;混合配置&lt;/h1&gt;
&lt;p&gt;不同人的对配置方式的偏好不一样，所以一个项目中几种不同的配置方式共存是很正常的。同时，一个配置类或者XML配置文件如果包含的内容太多，就需要拆分成好几个配置项目，否则就显得臃肿。&lt;/p&gt;

&lt;p&gt;也就意味着，一个项目有好几种配置方式，一种配置方式有好几个配置类或配置文件。如果存在这样的情况，就需要把不同的配置合并成一个，方便 Spring容器加载。如果不合并的化，那么 Spring 容器一个一个加载是很麻烦的。&lt;/p&gt;

&lt;p&gt;下面简单说明。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Java配置与XML配置合并
在 Java 配置类里面，利用 @ImportResource 注解导入 XML 配置&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;/**
* @ImportResource 里面的值的固定格式是
* classpath:xxx.xml，其中xxx就是XML配置
* 文件的名称。
* 
* 导入后，JavaConfig中的信息就和XML配置文件
* 中的信息合并了。只要 Spring容器加载了 JavaConfig
* 配置类，就自然而然的加载了 XML配置文件的信息。
*/
@Configurable
@ImportResource(&amp;quot;classpath:xxx.xml&amp;quot;)
public class JavaConfig {
	// do something
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;Java配置类和Java配置类合并
利用 @Import 导入另外一个配置类&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;/**
* OtherConfig.class 是另外一个配置类，可以在任何包路径下，
* 其他的同上。
*/
@Configurable
@Import(OtherConfig.class)
public class JavaConfig {
	// do something
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;XML配置文件与Java配置类合并&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&amp;lt;!-- XXX 是 Java配置类的名称 --&amp;gt;
&amp;lt;!-- 当 ClassPathXmlApplicationContext 容器加载了XML文件时，XXX配置类中的信息也一样会被加载。 --&amp;gt;
&amp;lt;bean class=&amp;quot;XXX&amp;quot; /&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;XML配置文件与XML配置文件合并&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&amp;lt;!-- 道理同上 --&amp;gt;
&amp;lt;import resource=&amp;quot;xxx.xml&amp;quot; /&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h1 id=&quot;section-3&quot;&gt;一些注意事项&lt;/h1&gt;
&lt;p&gt;时间有限，不可能讲把具体细节讲的面面俱到，所以这个博客只记录原理性的东西。所以要真正的使用这个框架，看博客坑定不够，必须看相关书籍。&lt;/p&gt;

&lt;p&gt;下面记录一些额外的知识点。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Java注解方式中的自动扫描，其默认扫描的地方是配置类所在的包。不过这个地方可以自己配置。可以看源码注释。下面列举几种：&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;// 指定多个包路径
@ComponentScan(basePackages = {&amp;quot;xxx&amp;quot;, &amp;quot;yyy&amp;quot;})

// 制定多个类，扫描类所在的包
@ComponentScan(basePackageClasses = {&amp;quot;XXX.class&amp;quot;, &amp;quot;YYY.class&amp;quot;})&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;XML配置文件功能没有讲全，其实还有很多标签用来配置bean的细节。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;@Autowire 不仅仅可以添加在属性字段上，还可以添加到SETTER方法、构造方法上。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;@Bean 注解可以给 Bean 设置ID&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;// 返回的 bean 的 id 是 beanId
@Bean(&amp;quot;beanId&amp;quot;)
// an method&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;@Bean 注解的方法返回的 Bean 默认情况下是单例。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 24 Jul 2017 00:00:41 +0800</pubDate>
        <link>http://localhost:4000/2017/07/24/Spring%E7%B3%BB%E5%88%97-%E4%B8%89-%E5%88%9B%E5%BB%BABean%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BE%9D%E8%B5%96/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/07/24/Spring%E7%B3%BB%E5%88%97-%E4%B8%89-%E5%88%9B%E5%BB%BABean%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BE%9D%E8%B5%96/</guid>
        
        
        <category>Spring</category>
        
      </item>
    
      <item>
        <title>从“模式匹配”谈起</title>
        <description>
&lt;p&gt;几天前看到了王垠的一片博文——&lt;a href=&quot;http://www.yinwang.org/blog-cn/2017/07/06/master-pl&quot;&gt;如何掌握所有的程序语言&lt;/a&gt;。于是我想起了了解的一个“模式匹配”的概念。&lt;/p&gt;

&lt;p&gt;比如有一个字符串“Hello world”，很容易认识到这是一个“你好，世界”的英文。那么如果我按照下面这样写会怎么样呢？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Holle world&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;恩恩，依然认得出来，不过是有两个字母错位而已，如果我再改一改会怎么样？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Hoole world
Hoole woeld&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果不仔细看的话，勉强能够认识出是一个Hello world。我很好奇，为什么会这样？要不再改改？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Hooee uored&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;个人感觉，我没有从这个字符串联想到 Hello world。&lt;/p&gt;

&lt;p&gt;我觉得这其实是很奇怪的，为什么人能够识别出 Hello world？为什么出现个别拼错的字母依然能识别出 Hello world？为什么最后一个字符我没有识别出来？&lt;/p&gt;

&lt;p&gt;其实这涉及到一个“模式匹配”的问题。人识别这个 Hello world 的时候并不是依据一个一个字母来识别的，而是依据 Hello world 的某些“模式”来识别的，比如这样：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;H * * l *  w * * l d&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;星花代表任意字符，其余的字符相当于一个模板，人只要在字符中看到了类似的模板，就可以很大程度上认定这是一个 Hello world 的字符。&lt;/p&gt;

&lt;p&gt;这就是“模板匹配”，上面的模板只是众多模板中的其中一个，其实你可以写很多个。&lt;/p&gt;

&lt;p&gt;往深层次想一想，我觉得这个“模板匹配”其实就是提取事物共性的一种行为，你可以写出很多种不同的带有少量错别字的 Hello world，但是你总可以将它识别出来，这是因为人们大脑已经从 Hello world 里提取出了 H * * l *  w * * l d 这样一个“模板”，只要能和这个“模板”相匹配的字符串，就证明有相同的共性，人们就会识别出这个 Hello world。&lt;/p&gt;

&lt;p&gt;而王垠的博客里面其实也暗含了这个“模板匹配”这个概念。比如王垠提到了以下几个概念：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;变量定义&lt;/li&gt;
  &lt;li&gt;算术运算&lt;/li&gt;
  &lt;li&gt;for 循环语句，while 循环语句&lt;/li&gt;
  &lt;li&gt;函数定义，函数调用&lt;/li&gt;
  &lt;li&gt;递归&lt;/li&gt;
  &lt;li&gt;静态类型系统&lt;/li&gt;
  &lt;li&gt;类型推导&lt;/li&gt;
  &lt;li&gt;lambda 函数&lt;/li&gt;
  &lt;li&gt;面向对象&lt;/li&gt;
  &lt;li&gt;垃圾回收&lt;/li&gt;
  &lt;li&gt;指针算术&lt;/li&gt;
  &lt;li&gt;goto 语句&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其实细想一下，王垠提到的几个特性其实都是程序设计语言里面的“共性”。&lt;/p&gt;

&lt;p&gt;我们可以把“&lt;strong&gt;程序设计语言&lt;/strong&gt;”比喻成面向对象思想中的“&lt;strong&gt;接口&lt;/strong&gt;”。像什么“变量定义”、“算数运算”、“函数定义”之类的看做是“&lt;strong&gt;接口&lt;/strong&gt;“里面定义的方法。而Java、C/C++、Kotlin只不过是针对“&lt;strong&gt;程序设计语言&lt;/strong&gt;”这个接口的一个实现。而我们知道接口的实现是有很多种的，所以才会有众多的程序设计语言。但是我们也意识到，正是因为有了&lt;strong&gt;程序设计语言&lt;/strong&gt;这个接口，纵然有许多不同的实现，可这些实现只不过是为了达到某一个目的的不同的方式而已。&lt;/p&gt;

&lt;p&gt;所以说”&lt;strong&gt;程序设计语言&lt;/strong&gt;“就是不同语言的一个共性，也可以理解成为一个“模板”，只要你的语言是基于“&lt;strong&gt;程序设计语言&lt;/strong&gt;“这个接口，那么这门语言就逃不脱上述的那些”共性“。只要我们脑海里对这些”共性“——或者说是”模板“——有了清晰的理解，那么从某种意义层面上，的确可以说我们掌握了大多数程序设计语言。这就好比有了 “H * * l *  w * * l d”这个模板，我们就可以识别各种各样带错字的“hello world”。&lt;/p&gt;

&lt;p&gt;其实不仅仅限于程序设计语言，计算机科学的很多地方都涉及到了这个理念，这也是为什么一直强调要注重基础知识的学习，因为这些基础知识就是所谓的“&lt;strong&gt;模板&lt;/strong&gt;”，各种花花绿绿的技术其实都是建立在这个“&lt;strong&gt;模板&lt;/strong&gt;”之上。而作为一名计算机专业的学生，认识到这一点是非常重要的。&lt;/p&gt;
</description>
        <pubDate>Sat, 08 Jul 2017 21:56:31 +0800</pubDate>
        <link>http://localhost:4000/2017/07/08/%E4%BB%8E-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D-%E8%B0%88%E8%B5%B7/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/07/08/%E4%BB%8E-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D-%E8%B0%88%E8%B5%B7/</guid>
        
        <category>思考</category>
        
        
        <category>思考</category>
        
      </item>
    
      <item>
        <title>Linux内核完全剖析（一）—— 微型计算机组成结构</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#i0&quot; id=&quot;markdown-toc-i0&quot;&gt;I/0端口寻址&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#io&quot; id=&quot;markdown-toc-io&quot;&gt;I/O访问控制&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;主存储器（内存）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#cmos&quot; id=&quot;markdown-toc-cmos&quot;&gt;CMOS存储器&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;异步串行通信和同步串行通信的区别&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;重新看了Linux内核完全剖析的第二章，记录几个关键的概念。&lt;/p&gt;

&lt;h1 id=&quot;i0&quot;&gt;I/0端口寻址&lt;/h1&gt;
&lt;p&gt;CPU为了访问I/O接口控制器上的数据，首先需要知道它们的地址。这种地址就是I/O端口地址。I/O端口的编址分为两种：统一编址和独立编址。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;统一端口编址
  把I/O控制器的端口地址归入存储器的寻址空间，这种方式也叫存储器映射编址。CPU访问一个I/O控制器就好比访问一个内存地址空间。&lt;/li&gt;
  &lt;li&gt;I/O端口独立编址
  I/O控制器的端口地址作为一个独立的地址空间，称之为I/O地址空间。每一个端口都和一个I/O地址对应，访问I/O地址的时候需要专门的I/O指令。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;io&quot;&gt;I/O访问控制&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;程序循环查询
  程序读取I/O端口数据时，是由CPU循环对I/O控制器的状态进行判断，判断是否可以读取数据。这种方式特别耗费CPU时间片。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;终端处理方式
  I/O控制器有数据时，通过终端向CPU发起请求。CPU响应中断暂停当前执行的程序，转而去处理I/O控制器，处理完毕后再返回处理暂停执行的程序。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DMA传输方式
  DMA —— Direct Memory Access —— 用于I/O设备和系统内存进行的批量数据传输，此过程不需要CPU的参与，操作效率很高&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section&quot;&gt;主存储器（内存）&lt;/h1&gt;
&lt;p&gt;主要讨论主存储器（内存）中的数据分布。&lt;/p&gt;

&lt;p&gt;早期的PC系统的主存储器大小很小，CPU只有20根地址线，内存最大只有1024KB（1MB）。目前的计算机内存变大了（此处讨论4G大小），为了以前PC在软件上兼容，内存在1MB以下的物理地址空间的使用分配上依然和以前一样。只不过由于BIOS处于CPU能够寻址空间的最高端，原本1MB处的BIOS的位置被用作BIOS的影子（shadow）区域，运行时4GB处的BIOS的代码会被复制到这个地方。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/internal_storage_struct.jpg&quot; alt=&quot;内存管理&quot; /&gt;&lt;/p&gt;

&lt;p&gt;计算机启动初始化的时候，4G空间中的640KB~1MB和4GB处的最后64KB以外的空间用作系统的内存。&lt;/p&gt;

&lt;p&gt;在Linux 0.1中，0~640KB用作系统内核代码和数据区域。640KB ~ 1MB用于I/0设备端口的映射，其中640KB~1MB空间用作BIOS影子区域和I/0端口映射的地址。BIOS影子区域位于最后的64KB处，运行时会将4GB地址最高端的BIOS复制到这个地方。4GB处的64KB用作存储实际的BIOS代码。1MB~16MB用作系统内核分配的主内存区。&lt;/p&gt;

&lt;p&gt;具体运行的时候，CPU会设置CS寄存器为0xF000，这样段基址就是0xFFFF0000，同时段长度被设置为64KB，也就是4GB空间的最后64KB处，也就是BIOS所在的地方，然后设置IP寄存器为0XFFF0，这样CS:IP指针就指向了0xFFFFFFF0处。BIOS在这个地方设置了一个跳转指令，跳到BIOS的某一个地方去执行。因为段长度是64KB，为了访问整个4GB空间，CPU会使用32位访问方式将数据段寄存器的访问范围设置为4GB。&lt;/p&gt;

&lt;p&gt;然后BIOS经过了一系列的硬件初始化工作之后，就会把BIOS复制到1MB空间处，也就是前文所说的BIOS影子区域，然后跳到这个地方开始运行。最后BIOS会从设备中将操作系统引导程序加载到0x7c00处的地方（31KB）开始执行系统引导程序。&lt;/p&gt;

&lt;h1 id=&quot;cmos&quot;&gt;CMOS存储器&lt;/h1&gt;

&lt;p&gt;CMOS存储器用来存储计算机的实时时钟信息和相关硬件配置信息，其地址空间位于主存地址空间之外，访问时需要使用I/O指令。&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;异步串行通信和同步串行通信的区别&lt;/h1&gt;

&lt;p&gt;串行通信就是计算机和计算机/设备之间的信息交互，信息的和格式可以拿计算机网络中学过的帧来类比。异步和同步的区别就是传输数据时的帧的长度不一样。其中异步通信时传输是以一个字符或者一个通信单位作为一帧，而同步通信在传输时是以多个字符或字节流作为一个帧。&lt;/p&gt;

</description>
        <pubDate>Sat, 08 Jul 2017 21:04:41 +0800</pubDate>
        <link>http://localhost:4000/2017/07/08/Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E5%89%96%E6%9E%90-%E4%B8%80-%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/07/08/Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E5%89%96%E6%9E%90-%E4%B8%80-%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84/</guid>
        
        <category>Linux内核</category>
        
        
        <category>Linux内核剖析</category>
        
      </item>
    
      <item>
        <title>Spring系列（二）—— Spring内部实现的简单理解</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;从自动扫描说起&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;如何实现的&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;看懂本文需要准备的知识：
* Java反射
* Java注解
* 依赖注入（Dependency Injection，DI)
* Spring 是如何使用注解的 （比如@Bean，@Component之类）
* 阅读过上一篇&lt;a href=&quot;https://stormphoenix.github.io/2017/06/24/Spring系列-一-初识Spring/&quot;&gt;博客&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;从自动扫描说起&lt;/h1&gt;

&lt;p&gt;在 Spring 里面有一个我觉得比较厉害的功能——自动扫描。不了解的没有关系下面我举一个例子来说明一下。&lt;/p&gt;

&lt;p&gt;例子依旧沿用 Spring 系列的上一篇&lt;a href=&quot;https://stormphoenix.github.io/2017/06/24/Spring系列-一-初识Spring/&quot;&gt;博客&lt;/a&gt;的例子：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;/**
* 在上一篇的例子上做了修改，改成了使用 Spring 框架的形式
*/
public class Kid {
	/**
	* @Autowire 是 Spring 里面的一个注解，
	* 表示被注解的属性需要被外界注入。
	*
	* Autowire 的意思就是自动装配
	*/
	@Autowire
    private Ball ball;

	public vodi play() {
		ball.play();
	}
}

public interface Ball {
	void play();
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;在上一篇博客中，我留下了一个疑问，Kid 里面的 Ball 是需要被外界注入的，那么到底是谁注入的？（反正不是程序员自己）这就涉及到 Spring 的自动扫描功能了！&lt;/p&gt;

&lt;p&gt;假设我在配置文件中配置 Spring 使用自动扫描功能（具体如何配置的目前不管，先了解原理），Spring 就会将程序员指定的包路径下面的所有的类全部扫描一遍，读取里面的信息。如果 Spring 读取 Kid 类时，发现有一个属性字段 ball 被加上了 @Autowire 注解，那么就会在 &lt;strong&gt;Spring容器&lt;/strong&gt; 里面查找是否有类型是 Ball 的一个 &lt;strong&gt;Bean&lt;/strong&gt; 的实现，如果有，就会把这个 Bean 赋值给 Kid 的 ball 字段。从而实现了 Spring 的 &lt;strong&gt;DI&lt;/strong&gt; 功能。&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;如何实现的&lt;/h1&gt;
&lt;p&gt;这个神奇的自动扫描、自动注入是如何实现的？我查找了一些资料，这里仅谈谈个人理解。&lt;/p&gt;

&lt;p&gt;首先，Spring 会读取配置，从配置中直到它要扫描的包，然后解析包里面的所有的类。那么关键就是如何解析了。解析的方法就是利用 &lt;strong&gt;Java 反射&lt;/strong&gt;，是 &lt;strong&gt;Java 反射&lt;/strong&gt;！&lt;/p&gt;

&lt;p&gt;Java 反射可以解析类的各种属性，有构造器、方法、属性等等。而 Spring 就利用这个特性将包里面所有被 @Bean、@Service、@Component 注解的的类全部解析一遍，并封装成一个 Bean 信息类，这个 Bean 信息类包含了很多信息，有 Bean 的 constructor信息、method信息、property信息等等。然后，&lt;strong&gt;最重要的一步&lt;/strong&gt;，将这个 Bean 信息类放进一个 map 里面，所谓的 map 其实就是前文提到的 &lt;strong&gt;Spring容器&lt;/strong&gt;！理解这个很关键！&lt;/p&gt;

&lt;p&gt;当程序需要一个 Bean 的实现的时候（比如上文的 @Autowire），Spring 就会在 ** Spring容器** 里面查询一下是否有这个 Bean 的定义 —— 翻译一下，就是在 map 里面查找是否有关于这个 Bean 定义的信息类。如果有，那就根据这个 Bean定义里面的 constructor 信息构造一个对象（构造完毕后在这个对象里面继续查找是否有需要注入的属性，所以你懂的，又是一层递归）。相反，如果没有在 Spring容器里面找到这个 Bean 的定义，那么就会抛出异常。&lt;/p&gt;

&lt;p&gt;当 Bean 对象完全被构造出来后，就会被赋值给需要它的地方，比如上面提到的 @Autowire（也就是所谓的依赖注入，Spring 已经在底层全部替你做好了）。&lt;/p&gt;

&lt;p&gt;最后是否需要根据 Bean定义构造一个对象也是需要商榷的，如果实现确定了这个 Bean对象是单例的（Singleton），那么就只构造一次这个对象，以后需要的话只要复用这个对象即可。&lt;/p&gt;

&lt;p&gt;完毕～～&lt;/p&gt;
</description>
        <pubDate>Sun, 25 Jun 2017 00:43:19 +0800</pubDate>
        <link>http://localhost:4000/2017/06/25/Spring%E7%B3%BB%E5%88%97-%E4%BA%8C-Spring%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/06/25/Spring%E7%B3%BB%E5%88%97-%E4%BA%8C-Spring%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</guid>
        
        <category>Spring</category>
        
        
        <category>Spring</category>
        
      </item>
    
      <item>
        <title>Spring系列（一）—— 初识Spring</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#spring&quot; id=&quot;markdown-toc-spring&quot;&gt;Spring采用的几种基本策略&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#beanbean&quot; id=&quot;markdown-toc-beanbean&quot;&gt;Bean和Bean容器&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#spring-1&quot; id=&quot;markdown-toc-spring-1&quot;&gt;Spring还可以做什么&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作为一个Java框架，Spring的根本使命就是简化Java开发。主要是让Java开发变得更加简单，更加具有可测试性，更加的松耦合。然而，Spring实现以上功能的仅仅只是基于少许的基本理念，比如说：松耦合、可重用等等。为了实现简化Java开发的使命，Spring采取了几种基本策略，如下。&lt;/p&gt;

&lt;h1 id=&quot;spring&quot;&gt;Spring采用的几种基本策略&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;基于对象的轻量级和最小侵入性
非侵入性编程，通俗点说就是某一个类在使用了框架和不使用框架的情况下都能够发挥相同的作用。用Struts2框架举个例子。&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;public class HelloAction extends ActionSupport {
	public String execute() {
		return &amp;quot;Hello world!&amp;quot;;
	}
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;在这个例子中如果想让&lt;code&gt;HelloAction&lt;/code&gt;能够正常的工作，必须要继承&lt;code&gt;ActionSupport&lt;/code&gt;，这就意味着&lt;code&gt;HelloAction&lt;/code&gt;和Struts2框架死死的绑定在了一起。这就是侵入式，从字面意思理解就是Struts2“侵入了“&lt;code&gt;HelloAction&lt;/code&gt;这个对象。这样带来了两个问题：
	1. 如果&lt;code&gt;HelloAction&lt;/code&gt;的功能需要被另一个模块重用，那么目标模块就不得不导入Struts框架，否则&lt;code&gt;HelloAction&lt;/code&gt;就无法工作，这样就加大了项目的代码冗余。
	2. 倘若决定不采用Struts2框架，那么这个&lt;code&gt;HelloAction&lt;/code&gt;将无法发挥它的正常功能，内部的逻辑代码必须要重写。所以，以上两点就降低了代码的可重用度。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过依赖注入（Dependency injection）和面向接口实现松耦合
程序中的对象和对象之间必然是有关联的。如果一个对象A需要使用B的某些功能，就可以称A对B产生了依赖。见如下代码&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;public class Kid {
	private Ball ball;

	public Kid() {
		this.ball = new Ball();
	}

	public void playBall() {
		ball.play();
	}
}

public class Ball {
	public void play() {
		// do something
	}
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;这里的 Kid 依赖于 Ball ，所以在Kid的构造方法里面创建了Ball接口的一个实现——Basketball。那么问题来了：构造 Ball 是 Kid 应该负责的事情吗？如果 Basketball 的构造方法改变了，那么 Kid 的代码是不是也需要改变呢？&lt;/p&gt;

&lt;p&gt;上面描述的就是两个类之间过度&lt;strong&gt;耦合&lt;/strong&gt;的现象，它导致的问题就是：一个类如果修改了将导致其他的类变化，从而可能引入了“打地鼠”式的bug。&lt;/p&gt;

&lt;p&gt;在看看下面两个修改过后的代码。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;public class Kid {
        private Ball ball;

	public Kid(Ball ball) {
		this.ball = ball;
	}
	// do something
}

public interface Ball {
	void play();
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;public class Kid {
	private Ball ball;

	public void setBall(Ball ball) {
		this.ball = ball;
	}
    // do something
}

public interface Ball {
	void play();
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Kid 不需要知道 Ball 是如何具体实现的，所以通过构造器或者setter方法注入 Ball —— &lt;strong&gt;依赖注入（Dependency Injection , DI)&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;Kid 不需要知道 Ball 是什么类型的，不需要知道到底是篮球还是足球，只需要知道 Ball 可以用来 play，所以 Ball 用接口进行替代—— &lt;strong&gt;面向接口编程&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;好处就是，不管 Ball 的实现如何变化，都不会影响到 Kid 的代码。（推荐一本书： Dhanji R. Prasanna 的 Dependency Injection，据说很不错）&lt;/p&gt;

&lt;p&gt;问题在于，这个构造器或者setter方法的中的 Ball 又是如何注入的？在 Spring 中，你不需要手动调用构造器或者setter方法，Spring会替你做的。关于这一点以后会讲到。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;基于切面（aspect-oriented programming）和惯例进行声明式编程
在一个应用中可能有许多地方都使用了相同的功能，这样导致的问题就是——代码冗余。同一个功能的代码重复的分布在系统的各个地方，如果需要对功能进行修改，就不得不在许多个功能调用点对代码进行修改。而AOP的作用，就是将这些地方的功能抽取出来形成一个独立的&lt;strong&gt;组件&lt;/strong&gt;，在需要的地方对组件进行调用。形象化的说，调用&lt;strong&gt;组件&lt;/strong&gt;的地方称之为&lt;strong&gt;切点&lt;/strong&gt;，所谓组件的调用就是将某个组件插入到某个&lt;strong&gt;切点&lt;/strong&gt;之中。不过令人惊喜的是，用Spring实现AOP甚至都不需要在切点编写调用方法！只要在配置文件声明切点的位置和相应的组件就行了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过切面和模板减少样板式代码
我见过最多的样板代码就是JDBC操作。Spring 提供了许多这样的模板，让开发人员只需要关注应用的逻辑。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;beanbean&quot;&gt;Bean和Bean容器&lt;/h1&gt;

&lt;p&gt;一个应用之中是有很多的对象的，对象和对象之间有着各种相互依赖的关系。在 Spring 中，每个对象被称之为 &lt;strong&gt;Bean&lt;/strong&gt;，所有的 Bean 都被容纳在 Spring 的一个容器（Container）里面，这个容器就是 &lt;strong&gt;Bean 容器&lt;/strong&gt;，而 Bean 和 Bean 之间的关系是 Bean 容器利用 DI 进行处理的。&lt;/p&gt;

&lt;p&gt;容器里面的对象是有生命周期的，Bean 容器管理着 Bean 的生命周期。Bean 容器会在每个 Bean 的不同生命周期阶段调用不同的生命周期方法（和Android中的Activity一模一样），下面举一个例子：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;public class MyBean implements BeanNameAware {
	/**
	* 如果MyBean处于设置BeanName的生命周期阶段，并且MyBean实现了
	* BeanNameAware接口，那么对应的setBeanName方法就会被调用，
	*/
	@Override
	public void setBeanName(String beanName) {
		// do something
	}
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Bean 容器是通过 bean 工厂 / 应用上下文（ApplicationContext）来创建所有的 bean 对象的，bean 工厂了解的不多，主要讲解应用上下文。
* AnnotationConfigApplicationContext
* ClassPathXmlApplicationContext
* 其他 … …&lt;/p&gt;

&lt;p&gt;上面列出了两个常用的应用上下文类。如果你在main方法中创建了相应的 Application Context，它就会自动加载相关的配置文件，从配置文件中读取它需要创建哪些 bean，并初始化它们。不同的 ApplicationContext 的区别在于加载的配置文件的不同。其中 AnnotationConfigApplicationContext 通过读取 Java 注解来创建 Bean ，而 ClassPathXmlApplicationContext 则是通过读取 xml 文件来读取。&lt;/p&gt;

&lt;h1 id=&quot;spring-1&quot;&gt;Spring还可以做什么&lt;/h1&gt;

&lt;p&gt;基于 Spring 的核心容器上，Spring 还有着许多功能模块。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SpringMVC —— 网站开发&lt;/li&gt;
  &lt;li&gt;数据集成和访问 —— 数据库操作&lt;/li&gt;
  &lt;li&gt;其他许多 … …&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 24 Jun 2017 23:26:34 +0800</pubDate>
        <link>http://localhost:4000/2017/06/24/Spring%E7%B3%BB%E5%88%97-%E4%B8%80-%E5%88%9D%E8%AF%86Spring/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/06/24/Spring%E7%B3%BB%E5%88%97-%E4%B8%80-%E5%88%9D%E8%AF%86Spring/</guid>
        
        <category>Spring</category>
        
        
        <category>Spring</category>
        
      </item>
    
      <item>
        <title>我失去了什么？</title>
        <description>
&lt;p&gt;学会反思，要反思什么东西呢？因为这些年来，我丢失了许多东西。对的，历史，哲学，人文、物理、地理之类的。这些东西我好像都丢失了，很痛惜。为什么呢？为什么为丢失这些东西而痛惜呢？&lt;/p&gt;

&lt;p&gt;回想起当年大一初进华农的时候，真的是怀着一腔热血，只求散发生命的光和热，用行为去感染周围的人，给他们带去正能量。我想学历史，是因为我爱这个国家的文化，爱人类的文化；我想学哲学，是因为我喜欢思考的感觉，这能够让我看清很多事情的本质；我想学人文，因为我喜欢听人类的故事，感受人性；我想学物理，因为我喜欢科学，喜欢探索真理；我想学地理，因为我喜欢那种知识广博的感觉。我想学，我想用自己所学的充实自己，成为一个完整的人。我想学，我想把自己的知识贡献给我深爱的这片土地。&lt;/p&gt;

&lt;p&gt;那时候，我能够做到每天做到每天6点起来跑步，认认真真上课，我从图书馆借了好多书… …现在回想起来，那时候的我就是最好的我，那段时光是最美好的时光。&lt;/p&gt;

&lt;p&gt;我怀念那段时光。可是，我也不知道什么时候，这一切都改变了。&lt;/p&gt;

&lt;p&gt;大一下学期，我加入了沸点工作室，加入了Android组，在课余时间弄Android开发。正是在这个时间点，我的人生发生了改变，我发现做应用是如此的美妙，因为我发现之前写的简单枯燥的代码竟然可以在手机上做出如此美妙的效果。恩恩，我的确沉迷了。&lt;/p&gt;

&lt;p&gt;我沉迷进了计算机，可是我所沉迷的，只是一种很浅层次的东西，我失去了了解计算机本质的机会。因为太沉迷，我把我年轻时的那些豪言壮语和梦想，全部抛弃了，恩恩，我的梦想也抛弃了。&lt;/p&gt;

&lt;p&gt;我这个人，就是那种一旦喜欢上一种东西，就会拼尽全力，把全部的热情投入进去。可是这也是我的缺点。因为太投入，就会忘记去看看这个世界，忘记了还有同样美好的事物值得我去追求。因为太投入，我缺少了对自身行为的反思。&lt;/p&gt;

&lt;p&gt;我把很多东西都丢了。&lt;/p&gt;

&lt;p&gt;如果我能够在很早以前对自身进行反思，不断的吸取经验改变自己的话，那么现在的我会是什么样子呢？&lt;/p&gt;

&lt;p&gt;我会有一个好的GPA，最终能够保研，去做自己一直梦寐以求的科学研究，回报世界。&lt;/p&gt;

&lt;p&gt;我会读很多的书，走很多的路，活的更加充实。&lt;/p&gt;

&lt;p&gt;我会更多的关注社会，看问题更加透彻。&lt;/p&gt;

&lt;p&gt;我会交到一些不同的朋友，有着共同改变世界的梦想。&lt;/p&gt;

&lt;p&gt;我会更加理解我所热爱的计算机科学的本质。&lt;/p&gt;

&lt;p&gt;我会带好整个班级，更加有爱。&lt;/p&gt;

&lt;p&gt;我会让沸点Android组成长的更快、更强。&lt;/p&gt;

&lt;p&gt;我会更多的关心我的亲人，多和他们聊天。&lt;/p&gt;

&lt;p&gt;恩恩，这是我梦想中的自己。&lt;/p&gt;

&lt;p&gt;这些年来，虽然失去了很多，但是也得到了一些真心朋友。唐平、健健、农哥，做你们的组长是我的幸运。倪子君，有你做朋友，我很开心。吴宇伦，你这个学霸，我好羡慕你。唐睿晨，相互嘲讽了这么久，你也是我人生的一部分。&lt;/p&gt;

&lt;p&gt;恩，有你们真好。从今天开始，不停的反思，只为了成为更好的一个人。
哪怕只是为了你们。&lt;/p&gt;

</description>
        <pubDate>Thu, 22 Jun 2017 23:44:46 +0800</pubDate>
        <link>http://localhost:4000/2017/06/22/%E6%88%91%E5%A4%B1%E5%8E%BB%E4%BA%86%E4%BB%80%E4%B9%88/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/06/22/%E6%88%91%E5%A4%B1%E5%8E%BB%E4%BA%86%E4%BB%80%E4%B9%88/</guid>
        
        
        <category>思考</category>
        
      </item>
    
      <item>
        <title>学习使用软件磁盘阵列</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#raid&quot; id=&quot;markdown-toc-raid&quot;&gt;RAID&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#raid---0&quot; id=&quot;markdown-toc-raid---0&quot;&gt;RAID - 0&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#raid---1&quot; id=&quot;markdown-toc-raid---1&quot;&gt;RAID - 1&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#raid-0--1--raid-1--0&quot; id=&quot;markdown-toc-raid-0--1--raid-1--0&quot;&gt;RAID 0 + 1 / RAID 1 + 0&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#raid---5&quot; id=&quot;markdown-toc-raid---5&quot;&gt;RAID - 5&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#spare-disk&quot; id=&quot;markdown-toc-spare-disk&quot;&gt;Spare Disk&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#software-raid--hardware-raid&quot; id=&quot;markdown-toc-software-raid--hardware-raid&quot;&gt;Software RAID 和 Hardware RAID&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#hardware-raid&quot; id=&quot;markdown-toc-hardware-raid&quot;&gt;Hardware RAID&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#software-raid&quot; id=&quot;markdown-toc-software-raid&quot;&gt;Software RAID&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#software-raid-1&quot; id=&quot;markdown-toc-software-raid-1&quot;&gt;设置 Software RAID&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;准备练习分区&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#raid-1&quot; id=&quot;markdown-toc-raid-1&quot;&gt;创建 RAID&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#raid-2&quot; id=&quot;markdown-toc-raid-2&quot;&gt;格式化并挂载 RAID&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#software-raid-&quot; id=&quot;markdown-toc-software-raid-&quot;&gt;利用 Software RAID 处理数据损毁&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#raid-3&quot; id=&quot;markdown-toc-raid-3&quot;&gt;设置开机挂载 RAID&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#software-raid-2&quot; id=&quot;markdown-toc-software-raid-2&quot;&gt;关闭 Software RAID&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;先从遇到的问题谈起，然后再讲讲什么是&lt;code&gt;磁盘阵列(Software RAID)&lt;/code&gt;和&lt;code&gt;软件磁盘阵列(Software RAID) &lt;/code&gt;，以及为什么要使用使用软件磁盘阵列。&lt;/p&gt;

&lt;p&gt;在使用磁盘时可能会遇到很多这样些问题。比如说在存储一些超大文件的时候，发现磁盘容量不够用了；磁盘长期进行大数据量的读写导致磁盘损毁，无法恢复数据之类的问题。为了解决这个问题，引入了RAID。&lt;/p&gt;

&lt;h1 id=&quot;raid&quot;&gt;RAID&lt;/h1&gt;

&lt;p&gt;RAID 全称是 Redundant Array of Inexpensive Disks（廉价磁盘冗余阵列）。从字面意思就可以看出了，RAID 是一个有多个磁盘组合在一起的磁盘组。之前不是提到过，引入 RAID 就是为了解决磁盘容量小，数据损毁无法恢复的问题，那么 RAID 是如何解决这几个问题的呢？答案是通过多个磁盘不同的组合方式来解决。RAID 的组合方式目前有四种，下面就分别介绍这四种，并说明他们解决了什么问题以及其优缺点。&lt;/p&gt;

&lt;h3 id=&quot;raid---0&quot;&gt;RAID - 0&lt;/h3&gt;

&lt;p&gt;这种组合方式采用了同种型号的、同样大小的两块磁盘组合在一起。然后将两块磁盘中划分等量大小的块（比如4KB）。在把文件写入磁盘的时候，会先将文件划分成等大小的块（块的大小和磁盘划分的块一样），然后将每一块交错的写入两块磁盘，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/0_1329357743uKQT.jpg&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;优点
    &lt;ul&gt;
      &lt;li&gt;增大了磁盘容量；读写文件的时候是两块磁盘同时工作，增大了读写的带宽；&lt;/li&gt;
      &lt;li&gt;减少了每一块磁盘的访问量，减少了负载。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;缺点&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;如果一块磁盘损毁了，那么存储的文件就会缺了一部分，整个文件就会损毁了。而且上述的 RAID - 0 只是以两块磁盘作为例子，如果采用多块磁盘，只要一块磁盘损毁了，那么整个磁盘组中保留的文件都会损毁，使得文件的损毁概率大大增加；&lt;/li&gt;
      &lt;li&gt;RAID - 0 中的所有磁盘都是同等大小了，如果采用了不一样大小的磁盘，当小容量的磁盘使用完毕，剩下的文件将全部被写入大磁盘，无形的降低了读写效率；&lt;/li&gt;
      &lt;li&gt;RAID - 0 阵列中每块磁盘会以阵列中最慢的那个磁盘的速率来传输数据。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;raid---1&quot;&gt;RAID - 1&lt;/h3&gt;

&lt;p&gt;将两块同种型号、同样大小的两块磁盘组合在一起（这里和 RAID - 0 是一样的），文件在写入的时候，会以两份的形式分别写入两块磁盘。如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/0_1329358091FfY1.jpg&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;优点&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;数据更加安全了，只要有一块磁盘上的数据损毁了，就可以从另外一个磁盘上恢复数据。这里不考虑两块磁盘恰好同时损毁的情况，这种情况发生的概率是很小的，因为只要发现了有一块磁盘损毁，我们就会将坏掉的磁盘更换掉，这样就降低了两块磁盘同时损毁的概率。&lt;/li&gt;
      &lt;li&gt;如果多个进程读取同一份文件，由于数据有两份，RAID 可以取得最佳的平衡。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;缺点&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;磁盘是冗余的，无形之中降低了磁盘的容量。举个例子就是：如果两块120GB的磁盘组合成 RAID - 1，其中一块磁盘是用来对文件备份的，所以实际的磁盘容量只有120GB。&lt;/li&gt;
      &lt;li&gt;写的性能可能会非常的差。因为数据在写入磁盘的过程中是要写入两份的，采用软件磁盘阵列（Software RAID，后文会提到)写入，由于只有一个南桥芯片，所以两份数据都要占用I/O总线，造成了性能很差。不过如果采用的是硬件磁盘阵列，那么磁盘阵列卡会将写入的数据复制一份，不会占用I/O总线，所以性能不会有太大损失。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;raid-0--1--raid-1--0&quot;&gt;RAID 0 + 1 / RAID 1 + 0&lt;/h3&gt;

&lt;p&gt;RAID 0 + 1 和 RAID 1 + 0 将前两者结合了起来，举个立即就是如果我限制有四块磁盘A、B、C、D，可以先将AB、CD分别组合成 RAID - 0，然后将这两个 RAID - 0 组合成 RAID - 1，反之亦可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/0_1329358502tPjX.jpg&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;raid---5&quot;&gt;RAID - 5&lt;/h3&gt;

&lt;p&gt;RAID - 5 至少需要3块磁盘，其中两块磁盘的组合和 RADI - 0 差不多，另外一块用来对其他两块做数据校验。假设有A、B、C三块磁盘，三块型号一样，大小相等。其中磁盘C用来对数据做校验。先将文件分块，循环写入A和B磁盘（就是先写入数据块到A，然后写入B，再写入A，在写入B … …），这样磁盘A上每一个数据块都和B上一个块对应，然后将这两个块的数据进行校验，得到的校验码（Parity）会被存入磁盘C对应的块，懂吧！那么这个校验码有什么用呢？当磁盘A或者B损毁了，那么其上的数据就可以通过校验码和另一块好的磁盘上的数据计算出来，从而实现数据的恢复。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/0_13293587958s5n.jpg&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;优点&lt;/p&gt;

    &lt;p&gt;将性能和数据安全综合考虑了进来。性能方面读性能和 RAID - 0差不多，但是写性能会慢。在容量方面，RAID - 5 是磁盘总数量减去1（因为有一个磁盘用来存储校验码）。安全方面，只要有一个磁盘损坏了，丢失的数据可以通过校验码和其他磁盘上的数据通过计算得到。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;缺点&lt;/p&gt;

    &lt;p&gt;写入的时候需要计算校验码，所以写入的速度较慢。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;补充&lt;/p&gt;

    &lt;p&gt;关于校验码的计算没有具体说明，不过感觉和计算机网络中的校验位的计算方法差不多。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;spare-disk&quot;&gt;Spare Disk&lt;/h3&gt;

&lt;p&gt;Spare Disk 在磁盘阵列中的地位属于预留的磁盘。它的功能是在某一个磁盘损坏的时候，系统可以自动将预留的磁盘加入磁盘阵列组，替代已经损坏的磁盘。&lt;/p&gt;

&lt;h1 id=&quot;software-raid--hardware-raid&quot;&gt;Software RAID 和 Hardware RAID&lt;/h1&gt;

&lt;h3 id=&quot;hardware-raid&quot;&gt;Hardware RAID&lt;/h3&gt;
&lt;p&gt;是利用硬件实现的 RAID ，它的性能会更好，因为 &lt;code&gt;Hardware RAID&lt;/code&gt; 专门的芯片处理 RAID，在进行数据传输时不会重复占用I/O总线，理论上性能会更好。不过缺点就是太贵。&lt;/p&gt;

&lt;h3 id=&quot;software-raid&quot;&gt;Software RAID&lt;/h3&gt;
&lt;p&gt;是利用软件来模拟硬件RAID的功能。模拟软件是 mdadm。在 &lt;code&gt;Hardware RAID&lt;/code&gt; 中是以磁盘作为 RAID 的基本单位，不过用软件模拟的话，只需要对磁盘分区即可，磁盘分区或磁盘是 &lt;code&gt;Software RAID&lt;/code&gt; 的基本单位。同时 &lt;code&gt;Software RAID&lt;/code&gt; 是针对 RAID 硬件的仿真，所以在系统看来，&lt;code&gt;Software RAID	&lt;/code&gt; 模拟的结果就是一个名为 &lt;code&gt;/dev/xxx&lt;/code&gt; 的设备，需要进行挂载。下文将具体讲解如何在Ubuntu上设置 &lt;code&gt;Software RAID&lt;/code&gt;。&lt;/p&gt;

&lt;h1 id=&quot;software-raid-1&quot;&gt;设置 Software RAID&lt;/h1&gt;

&lt;h3 id=&quot;section&quot;&gt;准备练习分区&lt;/h3&gt;

&lt;p&gt;在磁盘中划分出几个分区用作练习，展示一下本人的分区&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~# fdisk -l
Disk /dev/sda: 119.2 GiB, 128035676160 bytes, 250069680 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 4096 bytes
I/O size (minimum/optimal): 4096 bytes / 4096 bytes
Disklabel type: gpt
Disk identifier: 81B67BAA-92F7-4E6C-994A-EE5431EC7109

Device         Start       End   Sectors  Size Type
/dev/sda1       2048   1953791   1951744  953M EFI System
/dev/sda2    1953792  41015295  39061504 18.6G Linux filesystem
/dev/sda3   41015296  56639487  15624192  7.5G Linux swap
/dev/sda4   56639488 232491007 175851520 83.9G Linux filesystem
/dev/sda5  232491008 234588159   2097152    1G Linux filesystem
/dev/sda6  234588160 236685311   2097152    1G Linux filesystem
/dev/sda7  236685312 238782463   2097152    1G Linux filesystem
/dev/sda8  238782464 240879615   2097152    1G Linux filesystem
/dev/sda9  240879616 242976767   2097152    1G Linux filesystem
root@ubuntu:/home/Developer# df
Filesystem     1K-blocks     Used Available Use% Mounted on
udev             1945768        0   1945768   0% /dev
tmpfs             393196    11668    381528   3% /run
/dev/sda2       19091584 16613608   1485108  92% /
tmpfs            1965960   144672   1821288   8% /dev/shm
tmpfs               5120        4      5116   1% /run/lock
tmpfs            1965960        0   1965960   0% /sys/fs/cgroup
/dev/sda1         973952     3540    970412   1% /boot/efi
/dev/sda4       86414720 75004380   6997668  92% /home
cgmfs                100        0       100   0% /run/cgmanager/fs
tmpfs             393196       92    393104   1% /run/user/1001
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;fdisk -l&lt;/code&gt; 命令查看本机上有多少分区，&lt;code&gt;df&lt;/code&gt; 查看有哪些分区没有被挂载，这些些没有被挂载的分区用来做此次的实验。从上面可以看出 /dev/sda{5 - 9} 是此次的实验分区。&lt;/p&gt;

&lt;h3 id=&quot;raid-1&quot;&gt;创建 RAID&lt;/h3&gt;

&lt;p&gt;利用 &lt;code&gt;mdadm&lt;/code&gt; 命令创建 RAID&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~# mdadm --create --auto=yes /dev/raid0 --level=5 --raid-devices=4 --spare-devices=1 /dev/sda{5,6,7,8,9}
mdadm: /dev/raid0 is an invalid name for an md device.  Try /dev/md/raid0
root@ubuntu:~# mdadm --create --auto=yes /dev/md0 --level=5 --raid-devices=4 --spare-devices=1 /dev/sda{5,6,7,8,9} 
mdadm: Defaulting to version 1.2 metadata
mdadm: array /dev/md0 started.
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;--create&lt;/code&gt; 表示创建 RAID。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;--auto=yes&lt;/code&gt; 后面接上创建的 raid 设备的名字，第一次创建时使用了 &lt;code&gt;/dev/raid0&lt;/code&gt; 失败了，是因为必须使用md开头的命名规范。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;--raid-devices=N&lt;/code&gt; 表示使用多少个磁盘或者分区作为raid设备。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;--spare-devices=N1&lt;/code&gt; 表示使用多少个磁盘或者分区作为预备分区。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;--level=N&lt;/code&gt; 表示创建哪一种级别的raid&lt;/li&gt;
  &lt;li&gt;创建 raid 时，后面接上 &lt;code&gt;/dev/sdaX&lt;/code&gt; 表示哪些磁盘或者分区参加创建 raid ，注意了，这些磁盘或者分区的数量一定要和 raid-devices 加上 spare-devices 的值相等。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;查看创建完成的 RAID 设备信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~# mdadm --detail /dev/md0
/dev/md0:
Number   Major   Minor   RaidDevice State
0       8        5        0      active sync   /dev/sda5
1       8        6        1      active sync   /dev/sda6
2       8        7        2      active sync   /dev/sda7
5       8        8        3      active sync   /dev/sda8

4       8        9        -      spare   /dev/sda9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看最后几行，发现 &lt;code&gt;/dev/sda{5 - 8}&lt;/code&gt; 已经成为了 RAID 设备，&lt;code&gt;/dev/sda9&lt;/code&gt; 是预备的设备。&lt;/p&gt;

&lt;p&gt;补充一下，还可以通过 &lt;code&gt;cat /proc/mdstat&lt;/code&gt; 命令查看 RAID 设备信息。&lt;/p&gt;

&lt;h3 id=&quot;raid-2&quot;&gt;格式化并挂载 RAID&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~# mkfs -t ext4 /dev/md0
root@ubuntu:~# mkdir /mnt/raid
root@ubuntu:~# mount /dev/md0 /mnt/raid
root@ubuntu:~# df
Filesystem     1K-blocks     Used Available Use% Mounted on
/dev/sda2       19091584 16613668   1485048  92% /
/dev/sda1         973952     3540    970412   1% /boot/efi
/dev/sda4       86414720 75005600   6996448  92% /home
/dev/md0         3027728     4608   2849604   1% /mnt/raid
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;software-raid-&quot;&gt;利用 Software RAID 处理数据损毁&lt;/h1&gt;

&lt;p&gt;先向 &lt;code&gt;/mnt/raid&lt;/code&gt; 中添加一些数据，然后模拟 &lt;code&gt;/dev/sda8&lt;/code&gt; 的出错状态&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~# cp -a /etc /mnt/raid
root@ubuntu:~# mdadm --manage /dev/md0 --fail /dev/sda8
mdadm: set /dev/sda8 faulty in /dev/md0
root@ubuntu:~# mdadm --detail /dev/md0
Number   Major   Minor   RaidDevice State
0       8        5        0      active sync   /dev/sda5
1       8        6        1      active sync   /dev/sda6
2       8        7        2      active sync   /dev/sda7
4       8        9        3      active sync   /dev/sda9

5       8        8        -      faulty   /dev/sda8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看可发现 /dev/sda8 确实被设置出现了错误状态，接下来我将出现错误的磁盘从 RAID 中移除，并添加一块新的磁盘，在这里新的磁盘是 &lt;code&gt;/dev/sda10&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~# mdadm --manage /dev/md0 --add /dev/sda10 --remove /dev/sda8
root@ubuntu:~# mdadm --detail
Number   Major   Minor   RaidDevice State
0       8        5        0      active sync   /dev/sda5
1       8        6        1      active sync   /dev/sda6
2       8        7        2      active sync   /dev/sda7
4       8        9        3      active sync   /dev/sda9

6       8       10        -      spare   /dev/sda10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到 &lt;code&gt;/dev/sda8&lt;/code&gt; 已经被替换，而 &lt;code&gt;/dev/sda10&lt;/code&gt; 出现在预留磁盘的位置，可以查看一下 RAID 里面的数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~# du -sm /mnt/raid/*
17		/mnt/raid/etc
1		/mnt/raid/lost+found
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现数据完好。&lt;/p&gt;

&lt;h1 id=&quot;raid-3&quot;&gt;设置开机挂载 RAID&lt;/h1&gt;

&lt;p&gt;获取 RAID 设备的 uuid号码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~# mdadm --detail | grep -i uuid
UUID : 0a861ec3:399accad:00927385:a9c784c1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将设备号写入配置文件，供系统在挂载 RAID 设备的时候读取&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~# vim /etc/mdadm.conf
ARRAY /dev/md0 UUID=0a861ec3:399accad:00927385:a9c784c1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑 &lt;code&gt;/etc/fstab&lt;/code&gt; 进行开机挂载&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~# vim /etc/fstab
/dev/md0 /mnt/raid ext4 defaults 1 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重新挂载&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~# umount /dev/md0 ; mount -a
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;software-raid-2&quot;&gt;关闭 Software RAID&lt;/h1&gt;

&lt;p&gt;如何在你不想使用 Software RAID 的时候关闭 RAID，其实很简单，只要将你之前创建的各种配置文件删除即可，有一下几步：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 卸载 /dev/md0
2. 删除 `/etc/fstab` 中的记录
3. 通过 `mdadm --stop /dev/md0` 停止 RAID 服务
4. 删除 `/etc/mdadm.conf` 中的uid记录
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完。&lt;/p&gt;
</description>
        <pubDate>Wed, 14 Jun 2017 14:27:37 +0800</pubDate>
        <link>http://localhost:4000/2017/06/14/%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8%E8%BD%AF%E4%BB%B6%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/06/14/%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8%E8%BD%AF%E4%BB%B6%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97/</guid>
        
        <category>Linux</category>
        
        <category>RAID</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>使用Quota</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;注意事项&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;相关名词概念&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#quota&quot; id=&quot;markdown-toc-quota&quot;&gt;设置文件系统支持Quota&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#quota-1&quot; id=&quot;markdown-toc-quota-1&quot;&gt;创建Quota配置文件&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#quota-2&quot; id=&quot;markdown-toc-quota-2&quot;&gt;使用Quota&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#quota-3&quot; id=&quot;markdown-toc-quota-3&quot;&gt;生成Quota报表&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;其他&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Quota翻译成中文就是“限额”的意思，在Linux中Quota用来对用户（或用户组）的磁盘用量进行管理，这种管理在多用户的Linux系统上是很有必要的。假设有这样一种情况，好多个用户同时在主机上工作，其中一个用户无加限制的使用了很大的磁盘空间，这样就导致了其他用户可用的磁盘空间变小了，所以我们必须要对这个用户做一些磁盘容量的使用限制。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;注意事项&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Quota和ACL一样需要内核的支持，一样是针对整个文件系统而言的。所谓的针对整个文件系统，意思是假设你将&lt;code&gt;/dev/sda2&lt;/code&gt;挂载了&lt;code&gt;/home&lt;/code&gt;目录下并设置Quota，那么受影响的只是&lt;code&gt;/home&lt;/code&gt;下面所有的目录，其他目录是不会受影响的。还有一点，Quota一般是默认打开的，如果没有那就需要手动打开Quota哟。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Quota只针对普通用户有效，对root无效&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section-1&quot;&gt;相关名词概念&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;容量限制
  容量限制包括block限制和inode限制。通过设置block值的大小可以限制用户能够使用的最大磁盘容量，而设置inode值的大小限制了用户能够创建的最大文件数量&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;soft/hard
  soft限制（软限制）指明了用使用量超过多少时向用户发出警告，hard限制（硬限制）指明用户最多能使用多少用量，一旦超过就解除用户对磁盘的使用权（无法新增文件）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;grace time
  grace time（宽限时间）表示一个倒数时间，当用户的使用量处于soft和hard设置的值之间时，就会启动倒计时，如果超过了这个倒计时用户的磁盘使用量还处于soft和hard之间的话，用户的磁盘使用权就会锁住（无法新增文件）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;quota&quot;&gt;设置文件系统支持Quota&lt;/h1&gt;
&lt;p&gt;一般ext2、ext3和ext4都是能够支持Quota的。我们可以通过如下命令设置立即支持Quota。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~#mount -o remount, usrquota,grpquota /home
root@ubuntu:~#mount | grep home
/dev/sda4 on /home type ext4 (rw,relatime,quota,usrquota,grpquota,data=ordered)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有几点要注意
1. 只有root能够使用这个功能。
2. 此处用 &lt;code&gt;/home&lt;/code&gt; 目录做实验是因为/home恰好是挂载点。
3. usrquota是对单个用户做限制，grpquota是对一个组做限制。
4. 输出中的括号如果含有usrquota和grpquota，则证明该文件系统已经支持了quota。
5. 输出的信息其实存储在 &lt;code&gt;/etc/mtab&lt;/code&gt; 文件中。之前 &lt;code&gt;mount -o remount,usrquota,grpquota /home&lt;/code&gt; 其实是对文件系统进行了设置，这个设置会被保存在 &lt;code&gt;/etc/mtab&lt;/code&gt;文件中&lt;/p&gt;

&lt;p&gt;以上的命令只在此次开机中有效，如果想让系统在每次开机中都能够支持quota，则需要在/etc/fstab中添加如下语句&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LABEL=/home    /home    ext4    default,usrquota,grpquota 1 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在第四个字段的default后面加上usrquota，grpquota即可。&lt;/p&gt;

&lt;h1 id=&quot;quota-1&quot;&gt;创建Quota配置文件&lt;/h1&gt;
&lt;p&gt;有了文件系统支持quota还不够，还需要创建quota的配置文件，那么这个配置文件的作用就是用来保存不同的用户在此文件系统中已经使用的磁盘容量、容量使用限制等信息。&lt;/p&gt;

&lt;p&gt;那么quota具体是怎么工作的呢？在没有配置文件的时候，quota会扫描整个文件系统，查询每个用户（或用户组）拥有的文件总数和总大小，将查询到的信息记录到这个文件系统的根目录的配置文件之中。然后根据配置文件中对每个用户（或用户组）的限制信息来规定磁盘使用限制。&lt;/p&gt;

&lt;p&gt;也就是说，这个配置文件不是我们手动创建的，而是quota自己扫描整个文件系统信息然后创建的（因为你怎么知道不同的用户或者用户组使用了多少磁盘容量。。）。&lt;/p&gt;

&lt;p&gt;所以quotacheck命令是用来扫描这个磁盘，并在文件系统根目录创建配置文件的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~#quotacheck -augv -mf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;值得一提的是-mf两个选项，作用是强制扫描整个文件系统。因为某些时候会有其他程序在对文件系统进行读写，所以quotacheck查询出的文件数量可能是不准确的，系统会拒绝执行quotachec。不妥加上-mf参数就可以强制执行了，其他参数的含义不表。&lt;/p&gt;

&lt;p&gt;quotacheck命令先话一段时间扫描整个文件系统，执行完毕后会在/home目录下生成两个文件aquota.group和aquota.user两个文件，分别是针对用户组和用户的配置文件。&lt;/p&gt;

&lt;h1 id=&quot;quota-2&quot;&gt;使用Quota&lt;/h1&gt;

&lt;p&gt;开启Quota服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~#quotaon -avug
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关闭Quota服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~#quotaoff -a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑具体的限制值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;edquota -u [username] -g [groupname] -t
说明：
-u 对某一个用户进行编辑，后面接上用户名
-g 对某一个用户组进行编辑，后面接上用户组组名字
-t 设置宽限时间
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;样例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~#edquota -u stormphoenix
Disk quotas for user StormPhoenix (uid 1001):
Filesystem	blocks	    soft	hard    inodes      soft hard
/dev/sda4	60331452	0	    0	    1029831     0    0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分为7列，具体说明：
1. 具体的限制值是针对哪一个文件系统
2. 当前用户已经使用的磁盘容量
3. 当前用户使用磁盘容量的软限制值
4. 当前用户使用磁盘容量的硬限制值
5. 当前用户创建的文件数量
6. 当前用户穿件文件数量的软限制值
7. 当前用户创建文件数量的硬限制值&lt;/p&gt;

&lt;h1 id=&quot;quota-3&quot;&gt;生成Quota报表&lt;/h1&gt;
&lt;p&gt;简单的说就是查看用户或者用户组当前的使用量和限制量。&lt;/p&gt;

&lt;p&gt;查看某一个用户报表&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;quota -uvs StormPhoenix
Disk quotes for user Developer (uid 1001):
Filesystem		space		quota		limit		grace		files		quota		limit		grace
/dev/sda4		58918M		0K			0K						1030K		0			0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看某一个用户组报表同上，不同的是命令参数是 -gvs。&lt;/p&gt;

&lt;p&gt;查看某一个文件系统的限额报表。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~#repquota -auvs
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-2&quot;&gt;其他&lt;/h1&gt;
&lt;p&gt;介绍两个命令&lt;/p&gt;

&lt;p&gt;&lt;code&gt;warnquota&lt;/code&gt;用来对超出使用限制的用户发出警告，一般是用邮件发送。具体的发送信息是根据 &lt;code&gt;/etc/warnquota&lt;/code&gt; 的内容设置的。&lt;code&gt;warnquota&lt;/code&gt; 不会自动触发，需要手动启动，只要使用量处于soft和hard之间就会收到此警告（不过使用量到达了hard，就不会收到此消息了，因为用户的磁盘使用已经被剥夺，无法继续收信了）。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;setquota&lt;/code&gt; 可以直接在命令行中设置限额，用法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~#setquota [-u|-g] [name] block(soft) block(hard) inode(soft) inode(hard) [filesystem]
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Mon, 12 Jun 2017 22:49:35 +0800</pubDate>
        <link>http://localhost:4000/2017/06/12/%E4%BD%BF%E7%94%A8Quota/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/06/12/%E4%BD%BF%E7%94%A8Quota/</guid>
        
        <category>Linux</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>ACL的使用</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#acl&quot; id=&quot;markdown-toc-acl&quot;&gt;启动ACL支持&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#acl-1&quot; id=&quot;markdown-toc-acl-1&quot;&gt;设置ACL&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ACL全称访问控制列表（Access Controll List），用于提供owner，group，others的rwx以外的权限。ACL可以针对某一份文件、某一个用户和用户组来设置对文件的访问控制。&lt;/p&gt;

&lt;h1 id=&quot;acl&quot;&gt;启动ACL支持&lt;/h1&gt;

&lt;p&gt;ACL需要文件系统支持，所以需要查看自己的系统是否支持ACL。我们可以通过“fdisk -l”命令来查询文件系统挂载到了哪些磁盘分区中。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/Screenshot from 2017-06-10 19-31-56.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从图中可以看到有sda2和sda4两个磁盘分区挂载了文件系统。以&lt;code&gt;sda2&lt;/code&gt;为例子，用&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dumpe2fs -h /dev/sda2 | grep acl&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;命令去查询这个文件系统是否支持acl。只要有如下的acl出现，就证明系统启动了ACL支持。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/Screenshot from 2017-06-10 19-43-52.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;acl-1&quot;&gt;设置ACL&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;setfacl&lt;/code&gt; 用于设置针对某一个文件或某一个用户的acl属性。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;-m : 选项用于给文件添加某一个acl属性。例如：setfacl -m u:用户名称:权限 文件名字。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;-b：删除文件的所有acl属性。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/Screenshot from 2017-06-10 17-05-52.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;getfacl&lt;/code&gt; 查看某一个文件的acl属性。例如：getfacl testfile。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/Screenshot from 2017-06-10 16-27-38.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;mask&lt;/code&gt;说明。使用&lt;code&gt;getfacl&lt;/code&gt;命令的时候，会看到&lt;code&gt;mask&lt;/code&gt;这个字段。&lt;code&gt;mask&lt;/code&gt;代表在设置acl的时候，用户和用户组的权限范围不得超过&lt;code&gt;mask&lt;/code&gt;的设置值。例如如果user1针对文件test的acl属性是rwx，但是test的&lt;code&gt;mask&lt;/code&gt;字段设置为r–，由于user1的权限范围不超过mask设置的值，所以user1针对test文件只具有r–的权限。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 10 Jun 2017 16:07:39 +0800</pubDate>
        <link>http://localhost:4000/2017/06/10/ACL%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/06/10/ACL%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
        
        <category>Linux</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>Linux账号管理</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#uidgid&quot; id=&quot;markdown-toc-uidgid&quot;&gt;&lt;strong&gt;用户标识符UID与GID&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;&lt;strong&gt;相关文件结构&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;&lt;strong&gt;有效用户组和初始用户组&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;&lt;strong&gt;账号管理&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;uidgid&quot;&gt;&lt;strong&gt;用户标识符UID与GID&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;uid：用户的的id，用一个数字标志。&lt;/li&gt;
  &lt;li&gt;gid：用户所在组的id，用一个数值标志。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;&lt;strong&gt;相关文件结构&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;/etc/passwd文件结构&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;保存了系统中所有账号的信息，每一行都代表一个账号。账号的种类分为两个：&lt;code&gt;系统账号&lt;/code&gt;和&lt;code&gt;用户账号&lt;/code&gt;。其中系统账号是系统正常运行必须的。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;root:x:0:0:root:/root:/bin/bash&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;实例中的一行包括7列，用冒号“：”间隔分别说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 账号名称 

2. 账号密码，为了账号的安全性，账号的密码被保存在了/etc/shadow文件中，所以此处的密码变成了x

3. UID

4. GID

5. 用户信息说明，无重要用途

6. 主文件夹

7. Shell用户登录系统后取得的默认的shell
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;/etc/shadow文件结构&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;root:$6$qE8d/k2K$NpCCL0kCsQdpAO5pC4QD91YAKpTS8w6.qdhl/fgZurM/2npI2bvEYY.LDNtll/Jnqlq1GH.AH3Z8hGiKJgIfy.:17111:0:99999:7:::&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;提前说明三个概念：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;密码过期&lt;/strong&gt;：指超过了密码必须被修改的截止时间依然没有修改密码。在此情况下，用户依然可以使用此账号，但是账号登录的时候，系统会强制要求用户必须重新设置密码才能继续使用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;密码失效&lt;/strong&gt;：指的是密码过期超过了一定的天数，用户就无法使用此密码登录了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;账号失效&lt;/strong&gt;：账号无法使用了&lt;/p&gt;

&lt;p&gt;实例中的一行包括9列：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.账号名称

2.账号密码，不过已经被加密过了。由于固定的编码系统产生的密码长度必须一致，所以这个字段的长度改变之后，密码就会失效

3.最近更改密码的日期，这个时间是以1970年1月1日为1而累加得到的

4.密码被修改后必须过几天才能再修改

5.密码被更改后必须在多少天内再被修改

6.在密码过期前的多少天之内提醒用户密码快到期了

7.密码过期后的宽限时间，如果超过了这个时间，会发生密码失效

8.账号在过了规定的日期就会无法使用，这个时间的设置同3

9.保留字段
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;/etc/group文件结构&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;root:x:0:root&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;实例中的一行包括4列：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.用户组名字

2.用户组密码，给用户组管理员使用

3.GID

4.用户组支持的用户
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;/etc/gshadow文件结构&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;root:x:0:root&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;实例中的一行包括4列：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.用户组名字。

2.密码列，同/etc/shadow。不过如果密码列上面是!的话，代表此用户组没有管理员。

3.用户组管理员账号。

4.用户组成员，成员之间用逗号分隔开
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;&lt;strong&gt;有效用户组和初始用户组&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在/etc/passwd文件中，第四列就是用户的初始用户组组号GID，表示用户一登录系统就会取得该用户组的权限。而有效用户组是什么呢？当你登录shell，输入groups命令将会返回你所加入的所有用户组，其中第一个显示的用户组就是有效用户组。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当用户新建一个文件的时候，文件所属的用户组是创建者当前的有效用户组。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;newgrp命令可以切换当前用户的有效用户组，不过这个命令将会重新启动一个shell。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;&lt;strong&gt;账号管理&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;useradd 添加一个用户&lt;/li&gt;
  &lt;li&gt;passwd 修改用户的密码&lt;/li&gt;
  &lt;li&gt;chage 修改密码的时间设置&lt;/li&gt;
  &lt;li&gt;usermod 修改用户的信息&lt;/li&gt;
  &lt;li&gt;finger 查看当前登录用户的详细信息&lt;/li&gt;
  &lt;li&gt;chfn 修改个人信息&lt;/li&gt;
  &lt;li&gt;id 查看用户的uid和gid&lt;/li&gt;
  &lt;li&gt;groupadd 添加组&lt;/li&gt;
  &lt;li&gt;groupmod 修改group的相关参数&lt;/li&gt;
  &lt;li&gt;groupdel 删除用户组&lt;/li&gt;
  &lt;li&gt;gpasswd 用户组管理员功能&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 10 Jun 2017 13:05:30 +0800</pubDate>
        <link>http://localhost:4000/2017/06/10/Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/06/10/Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/</guid>
        
        <category>Linux</category>
        
        
        <category>Linux</category>
        
      </item>
    
  </channel>
</rss>
