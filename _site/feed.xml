<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description>为了生命中的美好，不妥协直到变老.</description>
    <link>http://stormphoenix.github.com/</link>
    <atom:link href="http://stormphoenix.github.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 07 Jul 2017 14:03:01 +0800</pubDate>
    <lastBuildDate>Fri, 07 Jul 2017 14:03:01 +0800</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>初识Spring（一）</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#spring&quot; id=&quot;markdown-toc-spring&quot;&gt;Spring采用的几种基本策略&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#beanbean&quot; id=&quot;markdown-toc-beanbean&quot;&gt;Bean和Bean容器&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#spring-1&quot; id=&quot;markdown-toc-spring-1&quot;&gt;Spring还可以做什么&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作为一个Java框架，Spring的根本使命就是简化Java开发。主要是让Java开发变得更加简单，更加具有可测试性，更加的松耦合。然而，Spring实现以上功能的仅仅只是基于少许的基本理念，比如说：松耦合、可重用等等。为了实现简化Java开发的使命，Spring采取了几种基本策略，如下。&lt;/p&gt;

&lt;h1 id=&quot;spring&quot;&gt;Spring采用的几种基本策略&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;基于对象的轻量级和最小侵入性&lt;br /&gt;
非侵入性编程，通俗点说就是某一个类在使用了框架和不使用框架的情况下都能够发挥相同的作用。用Struts2框架举个例子。&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class HelloAction extends ActionSupport {
	public String execute() {
		return &amp;quot;Hello world!&amp;quot;;
	}
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;在这个例子中如果想让&lt;code&gt;HelloAction&lt;/code&gt;能够正常的工作，必须要继承&lt;code&gt;ActionSupport&lt;/code&gt;，这就意味着&lt;code&gt;HelloAction&lt;/code&gt;和Struts2框架死死的绑定在了一起。这就是侵入式，从字面意思理解就是Struts2“侵入了“&lt;code&gt;HelloAction&lt;/code&gt;这个对象。这样带来了两个问题：&lt;br /&gt;
	1. 如果&lt;code&gt;HelloAction&lt;/code&gt;的功能需要被另一个模块重用，那么目标模块就不得不导入Struts框架，否则&lt;code&gt;HelloAction&lt;/code&gt;就无法工作，这样就加大了项目的代码冗余。&lt;br /&gt;
	2. 倘若决定不采用Struts2框架，那么这个&lt;code&gt;HelloAction&lt;/code&gt;将无法发挥它的正常功能，内部的逻辑代码必须要重写。所以，以上两点就降低了代码的可重用度。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过依赖注入（Dependency injection）和面向接口实现松耦合&lt;br /&gt;
程序中的对象和对象之间必然是有关联的。如果一个对象A需要使用B的某些功能，就可以称A对B产生了依赖。见如下代码&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class Kid {
	private Ball ball;

	public Kid() {
		this.ball = new Ball();
	}

	public void playBall() {
		ball.play();
	}
}

public class Ball {
	public void play() {
		// do something
	}
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;这里的 Kid 依赖于 Ball ，所以在Kid的构造方法里面创建了Ball接口的一个实现——Basketball。那么问题来了：构造 Ball 是 Kid 应该负责的事情吗？如果 Basketball 的构造方法改变了，那么 Kid 的代码是不是也需要改变呢？&lt;/p&gt;

&lt;p&gt;上面描述的就是两个类之间过度&lt;strong&gt;耦合&lt;/strong&gt;的现象，它导致的问题就是：一个类如果修改了将导致其他的类变化，从而可能引入了“打地鼠”式的bug。&lt;/p&gt;

&lt;p&gt;在看看下面两个修改过后的代码。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class Kid {
        private Ball ball;

	public Kid(Ball ball) {
		this.ball = ball;
	}
	// do something
}

public interface Ball {
	void play();
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class Kid {
	private Ball ball;

	public void setBall(Ball ball) {
		this.ball = ball;
	}
    // do something
}

public interface Ball {
	void play();
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Kid 不需要知道 Ball 是如何具体实现的，所以通过构造器或者setter方法注入 Ball —— &lt;strong&gt;依赖注入（Dependency Injection , DI)&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;Kid 不需要知道 Ball 是什么类型的，不需要知道到底是篮球还是足球，只需要知道 Ball 可以用来 play，所以 Ball 用接口进行替代—— &lt;strong&gt;面向接口编程&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;好处就是，不管 Ball 的实现如何变化，都不会影响到 Kid 的代码。（推荐一本书： Dhanji R. Prasanna 的 Dependency Injection，据说很不错）&lt;/p&gt;

&lt;p&gt;问题在于，这个构造器或者setter方法的中的 Ball 又是如何注入的？在 Spring 中，你不需要手动调用构造器或者setter方法，Spring会替你做的。关于这一点以后会讲到。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;基于切面（aspect-oriented programming）和惯例进行声明式编程&lt;br /&gt;
在一个应用中可能有许多地方都使用了相同的功能，这样导致的问题就是——代码冗余。同一个功能的代码重复的分布在系统的各个地方，如果需要对功能进行修改，就不得不在许多个功能调用点对代码进行修改。而AOP的作用，就是将这些地方的功能抽取出来形成一个独立的&lt;strong&gt;组件&lt;/strong&gt;，在需要的地方对组件进行调用。形象化的说，调用&lt;strong&gt;组件&lt;/strong&gt;的地方称之为&lt;strong&gt;切点&lt;/strong&gt;，所谓组件的调用就是将某个组件插入到某个&lt;strong&gt;切点&lt;/strong&gt;之中。不过令人惊喜的是，用Spring实现AOP甚至都不需要在切点编写调用方法！只要在配置文件声明切点的位置和相应的组件就行了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过切面和模板减少样板式代码&lt;br /&gt;
我见过最多的样板代码就是JDBC操作。Spring 提供了许多这样的模板，让开发人员只需要关注应用的逻辑。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;beanbean&quot;&gt;Bean和Bean容器&lt;/h1&gt;

&lt;p&gt;一个应用之中是有很多的对象的，对象和对象之间有着各种相互依赖的关系。在 Spring 中，每个对象被称之为 &lt;strong&gt;Bean&lt;/strong&gt;，所有的 Bean 都被容纳在 Spring 的一个容器（Container）里面，这个容器就是 &lt;strong&gt;Bean 容器&lt;/strong&gt;，而 Bean 和 Bean 之间的关系是 Bean 容器利用 DI 进行处理的。&lt;/p&gt;

&lt;p&gt;容器里面的对象是有生命周期的，Bean 容器管理着 Bean 的生命周期。Bean 容器会在每个 Bean 的不同生命周期阶段调用不同的生命周期方法（和Android中的Activity一模一样），下面举一个例子：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class MyBean implements BeanNameAware {
	/**
	* 如果MyBean处于设置BeanName的生命周期阶段，并且MyBean实现了
	* BeanNameAware接口，那么对应的setBeanName方法就会被调用，
	*/
	@Override
	public void setBeanName(String beanName) {
		// do something
	}
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Bean 容器是通过 bean 工厂 / 应用上下文（ApplicationContext）来创建所有的 bean 对象的，bean 工厂了解的不多，主要讲解应用上下文。&lt;br /&gt;
* AnnotationConfigApplicationContext&lt;br /&gt;
* ClassPathXmlApplicationContext&lt;br /&gt;
* 其他 … …&lt;/p&gt;

&lt;p&gt;上面列出了两个常用的应用上下文类。如果你在main方法中创建了相应的 Application Context，它就会自动加载相关的配置文件，从配置文件中读取它需要创建哪些 bean，并初始化它们。不同的 ApplicationContext 的区别在于加载的配置文件的不同。其中 AnnotationConfigApplicationContext 通过读取 Java 注解来创建 Bean ，而 ClassPathXmlApplicationContext 则是通过读取 xml 文件来读取。&lt;/p&gt;

&lt;h1 id=&quot;spring-1&quot;&gt;Spring还可以做什么&lt;/h1&gt;

&lt;p&gt;基于 Spring 的核心容器上，Spring 还有着许多功能模块。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SpringMVC —— 网站开发&lt;/li&gt;
  &lt;li&gt;数据集成和访问 —— 数据库操作&lt;/li&gt;
  &lt;li&gt;其他许多 … …&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 24 Jun 2017 23:26:34 +0800</pubDate>
        <link>http://stormphoenix.github.com/2017/06/24/%E5%88%9D%E8%AF%86Spring-%E4%B8%80/</link>
        <guid isPermaLink="true">http://stormphoenix.github.com/2017/06/24/%E5%88%9D%E8%AF%86Spring-%E4%B8%80/</guid>
        
        
        <category>Spring</category>
        
      </item>
    
      <item>
        <title>我失去了什么？</title>
        <description>
&lt;p&gt;学会反思，要反思什么东西呢？因为这些年来，我丢失了许多东西。对的，历史，哲学，人文、物理、地理之类的。这些东西我好像都丢失了，很痛惜。为什么呢？为什么为丢失这些东西而痛惜呢？&lt;/p&gt;

&lt;p&gt;回想起当年大一初进华农的时候，真的是怀着一腔热血，只求散发生命的光和热，用行为去感染周围的人，给他们带去正能量。我想学历史，是因为我爱这个国家的文化，爱人类的文化；我想学哲学，是因为我喜欢思考的感觉，这能够让我看清很多事情的本质；我想学人文，因为我喜欢听人类的故事，感受人性；我想学物理，因为我喜欢科学，喜欢探索真理；我想学地理，因为我喜欢那种知识广博的感觉。我想学，我想用自己所学的充实自己，成为一个完整的人。我想学，我想把自己的知识贡献给我深爱的这片土地。&lt;/p&gt;

&lt;p&gt;那时候，我能够做到每天做到每天6点起来跑步，认认真真上课，我从图书馆借了好多书… …现在回想起来，那时候的我就是最好的我，那段时光是最美好的时光。&lt;/p&gt;

&lt;p&gt;我怀念那段时光。可是，我也不知道什么时候，这一切都改变了。&lt;/p&gt;

&lt;p&gt;大一下学期，我加入了沸点工作室，加入了Android组，在课余时间弄Android开发。正是在这个时间点，我的人生发生了改变，我发现做应用是如此的美妙，因为我发现之前写的简单枯燥的代码竟然可以在手机上做出如此美妙的效果。恩恩，我的确沉迷了。&lt;/p&gt;

&lt;p&gt;我沉迷进了计算机，可是我所沉迷的，只是一种很浅层次的东西，我失去了了解计算机本质的机会。因为太沉迷，我把我年轻时的那些豪言壮语和梦想，全部抛弃了，恩恩，我的梦想也抛弃了。&lt;/p&gt;

&lt;p&gt;我这个人，就是那种一旦喜欢上一种东西，就会拼尽全力，把全部的热情投入进去。可是这也是我的缺点。因为太投入，就会忘记去看看这个世界，忘记了还有同样美好的事物值得我去追求。因为太投入，我缺少了对自身行为的反思。&lt;/p&gt;

&lt;p&gt;我把很多东西都丢了。&lt;/p&gt;

&lt;p&gt;如果我能够在很早以前对自身进行反思，不断的吸取经验改变自己的话，那么现在的我会是什么样子呢？&lt;/p&gt;

&lt;p&gt;我会有一个好的GPA，最终能够保研，去做自己一直梦寐以求的科学研究，回报世界。&lt;/p&gt;

&lt;p&gt;我会读很多的书，走很多的路，活的更加充实。&lt;/p&gt;

&lt;p&gt;我会更多的关注社会，看问题更加透彻。&lt;/p&gt;

&lt;p&gt;我会交到一些不同的朋友，有着共同改变世界的梦想。&lt;/p&gt;

&lt;p&gt;我会更加理解我所热爱的计算机科学的本质。&lt;/p&gt;

&lt;p&gt;我会带好整个班级，更加有爱。&lt;/p&gt;

&lt;p&gt;我会让沸点Android组成长的更快、更强。&lt;/p&gt;

&lt;p&gt;我会更多的关心我的亲人，多和他们聊天。&lt;/p&gt;

&lt;p&gt;恩恩，这是我梦想中的自己。&lt;/p&gt;

&lt;p&gt;这些年来，虽然失去了很多，但是也得到了一些真心朋友。唐平、健健、农哥，做你们的组长是我的幸运。倪子君，有你做朋友，我很开心。吴宇伦，你这个学霸，我好羡慕你。唐睿晨，相互嘲讽了这么久，你也是我人生的一部分。&lt;/p&gt;

&lt;p&gt;恩，有你们真好。从今天开始，不停的反思，只为了成为更好的一个人。&lt;br /&gt;
哪怕只是为了你们。&lt;/p&gt;

</description>
        <pubDate>Thu, 22 Jun 2017 23:44:46 +0800</pubDate>
        <link>http://stormphoenix.github.com/2017/06/22/%E6%88%91%E5%A4%B1%E5%8E%BB%E4%BA%86%E4%BB%80%E4%B9%88/</link>
        <guid isPermaLink="true">http://stormphoenix.github.com/2017/06/22/%E6%88%91%E5%A4%B1%E5%8E%BB%E4%BA%86%E4%BB%80%E4%B9%88/</guid>
        
        
        <category>反思</category>
        
      </item>
    
      <item>
        <title>学习使用软件磁盘阵列</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#raid&quot; id=&quot;markdown-toc-raid&quot;&gt;RAID&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#raid---0&quot; id=&quot;markdown-toc-raid---0&quot;&gt;RAID - 0&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#raid---1&quot; id=&quot;markdown-toc-raid---1&quot;&gt;RAID - 1&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#raid-0--1--raid-1--0&quot; id=&quot;markdown-toc-raid-0--1--raid-1--0&quot;&gt;RAID 0 + 1 / RAID 1 + 0&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#raid---5&quot; id=&quot;markdown-toc-raid---5&quot;&gt;RAID - 5&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#spare-disk&quot; id=&quot;markdown-toc-spare-disk&quot;&gt;Spare Disk&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#software-raid--hardware-raid&quot; id=&quot;markdown-toc-software-raid--hardware-raid&quot;&gt;Software RAID 和 Hardware RAID&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#hardware-raid&quot; id=&quot;markdown-toc-hardware-raid&quot;&gt;Hardware RAID&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#software-raid&quot; id=&quot;markdown-toc-software-raid&quot;&gt;Software RAID&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#software-raid-1&quot; id=&quot;markdown-toc-software-raid-1&quot;&gt;设置 Software RAID&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;准备练习分区&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#raid-1&quot; id=&quot;markdown-toc-raid-1&quot;&gt;创建 RAID&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#raid-2&quot; id=&quot;markdown-toc-raid-2&quot;&gt;格式化并挂载 RAID&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#software-raid-&quot; id=&quot;markdown-toc-software-raid-&quot;&gt;利用 Software RAID 处理数据损毁&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#raid-3&quot; id=&quot;markdown-toc-raid-3&quot;&gt;设置开机挂载 RAID&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#software-raid-2&quot; id=&quot;markdown-toc-software-raid-2&quot;&gt;关闭 Software RAID&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;先从遇到的问题谈起，然后再讲讲什么是&lt;code&gt;磁盘阵列(Software RAID)&lt;/code&gt;和&lt;code&gt;软件磁盘阵列(Software RAID) &lt;/code&gt;，以及为什么要使用使用软件磁盘阵列。&lt;/p&gt;

&lt;p&gt;在使用磁盘时可能会遇到很多这样些问题。比如说在存储一些超大文件的时候，发现磁盘容量不够用了；磁盘长期进行大数据量的读写导致磁盘损毁，无法恢复数据之类的问题。为了解决这个问题，引入了RAID。&lt;/p&gt;

&lt;h1 id=&quot;raid&quot;&gt;RAID&lt;/h1&gt;

&lt;p&gt;RAID 全称是 Redundant Array of Inexpensive Disks（廉价磁盘冗余阵列）。从字面意思就可以看出了，RAID 是一个有多个磁盘组合在一起的磁盘组。之前不是提到过，引入 RAID 就是为了解决磁盘容量小，数据损毁无法恢复的问题，那么 RAID 是如何解决这几个问题的呢？答案是通过多个磁盘不同的组合方式来解决。RAID 的组合方式目前有四种，下面就分别介绍这四种，并说明他们解决了什么问题以及其优缺点。&lt;/p&gt;

&lt;h3 id=&quot;raid---0&quot;&gt;RAID - 0&lt;/h3&gt;

&lt;p&gt;这种组合方式采用了同种型号的、同样大小的两块磁盘组合在一起。然后将两块磁盘中划分等量大小的块（比如4KB）。在把文件写入磁盘的时候，会先将文件划分成等大小的块（块的大小和磁盘划分的块一样），然后将每一块交错的写入两块磁盘，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/0_1329357743uKQT.jpg&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;优点
    &lt;ul&gt;
      &lt;li&gt;增大了磁盘容量；读写文件的时候是两块磁盘同时工作，增大了读写的带宽；&lt;/li&gt;
      &lt;li&gt;减少了每一块磁盘的访问量，减少了负载。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;缺点&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;如果一块磁盘损毁了，那么存储的文件就会缺了一部分，整个文件就会损毁了。而且上述的 RAID - 0 只是以两块磁盘作为例子，如果采用多块磁盘，只要一块磁盘损毁了，那么整个磁盘组中保留的文件都会损毁，使得文件的损毁概率大大增加；&lt;/li&gt;
      &lt;li&gt;RAID - 0 中的所有磁盘都是同等大小了，如果采用了不一样大小的磁盘，当小容量的磁盘使用完毕，剩下的文件将全部被写入大磁盘，无形的降低了读写效率；&lt;/li&gt;
      &lt;li&gt;RAID - 0 阵列中每块磁盘会以阵列中最慢的那个磁盘的速率来传输数据。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;raid---1&quot;&gt;RAID - 1&lt;/h3&gt;

&lt;p&gt;将两块同种型号、同样大小的两块磁盘组合在一起（这里和 RAID - 0 是一样的），文件在写入的时候，会以两份的形式分别写入两块磁盘。如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/0_1329358091FfY1.jpg&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;优点&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;数据更加安全了，只要有一块磁盘上的数据损毁了，就可以从另外一个磁盘上恢复数据。这里不考虑两块磁盘恰好同时损毁的情况，这种情况发生的概率是很小的，因为只要发现了有一块磁盘损毁，我们就会将坏掉的磁盘更换掉，这样就降低了两块磁盘同时损毁的概率。&lt;/li&gt;
      &lt;li&gt;如果多个进程读取同一份文件，由于数据有两份，RAID 可以取得最佳的平衡。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;缺点&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;磁盘是冗余的，无形之中降低了磁盘的容量。举个例子就是：如果两块120GB的磁盘组合成 RAID - 1，其中一块磁盘是用来对文件备份的，所以实际的磁盘容量只有120GB。&lt;/li&gt;
      &lt;li&gt;写的性能可能会非常的差。因为数据在写入磁盘的过程中是要写入两份的，采用软件磁盘阵列（Software RAID，后文会提到)写入，由于只有一个南桥芯片，所以两份数据都要占用I/O总线，造成了性能很差。不过如果采用的是硬件磁盘阵列，那么磁盘阵列卡会将写入的数据复制一份，不会占用I/O总线，所以性能不会有太大损失。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;raid-0--1--raid-1--0&quot;&gt;RAID 0 + 1 / RAID 1 + 0&lt;/h3&gt;

&lt;p&gt;RAID 0 + 1 和 RAID 1 + 0 将前两者结合了起来，举个立即就是如果我限制有四块磁盘A、B、C、D，可以先将AB、CD分别组合成 RAID - 0，然后将这两个 RAID - 0 组合成 RAID - 1，反之亦可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/0_1329358502tPjX.jpg&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;raid---5&quot;&gt;RAID - 5&lt;/h3&gt;

&lt;p&gt;RAID - 5 至少需要3块磁盘，其中两块磁盘的组合和 RADI - 0 差不多，另外一块用来对其他两块做数据校验。假设有A、B、C三块磁盘，三块型号一样，大小相等。其中磁盘C用来对数据做校验。先将文件分块，循环写入A和B磁盘（就是先写入数据块到A，然后写入B，再写入A，在写入B … …），这样磁盘A上每一个数据块都和B上一个块对应，然后将这两个块的数据进行校验，得到的校验码（Parity）会被存入磁盘C对应的块，懂吧！那么这个校验码有什么用呢？当磁盘A或者B损毁了，那么其上的数据就可以通过校验码和另一块好的磁盘上的数据计算出来，从而实现数据的恢复。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/0_13293587958s5n.jpg&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;优点&lt;/p&gt;

    &lt;p&gt;将性能和数据安全综合考虑了进来。性能方面读性能和 RAID - 0差不多，但是写性能会慢。在容量方面，RAID - 5 是磁盘总数量减去1（因为有一个磁盘用来存储校验码）。安全方面，只要有一个磁盘损坏了，丢失的数据可以通过校验码和其他磁盘上的数据通过计算得到。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;缺点&lt;/p&gt;

    &lt;p&gt;写入的时候需要计算校验码，所以写入的速度较慢。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;补充&lt;/p&gt;

    &lt;p&gt;关于校验码的计算没有具体说明，不过感觉和计算机网络中的校验位的计算方法差不多。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;spare-disk&quot;&gt;Spare Disk&lt;/h3&gt;

&lt;p&gt;Spare Disk 在磁盘阵列中的地位属于预留的磁盘。它的功能是在某一个磁盘损坏的时候，系统可以自动将预留的磁盘加入磁盘阵列组，替代已经损坏的磁盘。&lt;/p&gt;

&lt;h1 id=&quot;software-raid--hardware-raid&quot;&gt;Software RAID 和 Hardware RAID&lt;/h1&gt;

&lt;h3 id=&quot;hardware-raid&quot;&gt;Hardware RAID&lt;/h3&gt;
&lt;p&gt;是利用硬件实现的 RAID ，它的性能会更好，因为 &lt;code&gt;Hardware RAID&lt;/code&gt; 专门的芯片处理 RAID，在进行数据传输时不会重复占用I/O总线，理论上性能会更好。不过缺点就是太贵。&lt;/p&gt;

&lt;h3 id=&quot;software-raid&quot;&gt;Software RAID&lt;/h3&gt;
&lt;p&gt;是利用软件来模拟硬件RAID的功能。模拟软件是 mdadm。在 &lt;code&gt;Hardware RAID&lt;/code&gt; 中是以磁盘作为 RAID 的基本单位，不过用软件模拟的话，只需要对磁盘分区即可，磁盘分区或磁盘是 &lt;code&gt;Software RAID&lt;/code&gt; 的基本单位。同时 &lt;code&gt;Software RAID&lt;/code&gt; 是针对 RAID 硬件的仿真，所以在系统看来，&lt;code&gt;Software RAID	&lt;/code&gt; 模拟的结果就是一个名为 &lt;code&gt;/dev/xxx&lt;/code&gt; 的设备，需要进行挂载。下文将具体讲解如何在Ubuntu上设置 &lt;code&gt;Software RAID&lt;/code&gt;。&lt;/p&gt;

&lt;h1 id=&quot;software-raid-1&quot;&gt;设置 Software RAID&lt;/h1&gt;

&lt;h3 id=&quot;section&quot;&gt;准备练习分区&lt;/h3&gt;

&lt;p&gt;在磁盘中划分出几个分区用作练习，展示一下本人的分区&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~# fdisk -l
Disk /dev/sda: 119.2 GiB, 128035676160 bytes, 250069680 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 4096 bytes
I/O size (minimum/optimal): 4096 bytes / 4096 bytes
Disklabel type: gpt
Disk identifier: 81B67BAA-92F7-4E6C-994A-EE5431EC7109

Device         Start       End   Sectors  Size Type
/dev/sda1       2048   1953791   1951744  953M EFI System
/dev/sda2    1953792  41015295  39061504 18.6G Linux filesystem
/dev/sda3   41015296  56639487  15624192  7.5G Linux swap
/dev/sda4   56639488 232491007 175851520 83.9G Linux filesystem
/dev/sda5  232491008 234588159   2097152    1G Linux filesystem
/dev/sda6  234588160 236685311   2097152    1G Linux filesystem
/dev/sda7  236685312 238782463   2097152    1G Linux filesystem
/dev/sda8  238782464 240879615   2097152    1G Linux filesystem
/dev/sda9  240879616 242976767   2097152    1G Linux filesystem
root@ubuntu:/home/Developer# df
Filesystem     1K-blocks     Used Available Use% Mounted on
udev             1945768        0   1945768   0% /dev
tmpfs             393196    11668    381528   3% /run
/dev/sda2       19091584 16613608   1485108  92% /
tmpfs            1965960   144672   1821288   8% /dev/shm
tmpfs               5120        4      5116   1% /run/lock
tmpfs            1965960        0   1965960   0% /sys/fs/cgroup
/dev/sda1         973952     3540    970412   1% /boot/efi
/dev/sda4       86414720 75004380   6997668  92% /home
cgmfs                100        0       100   0% /run/cgmanager/fs
tmpfs             393196       92    393104   1% /run/user/1001
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;fdisk -l&lt;/code&gt; 命令查看本机上有多少分区，&lt;code&gt;df&lt;/code&gt; 查看有哪些分区没有被挂载，这些些没有被挂载的分区用来做此次的实验。从上面可以看出 /dev/sda{5 - 9} 是此次的实验分区。&lt;/p&gt;

&lt;h3 id=&quot;raid-1&quot;&gt;创建 RAID&lt;/h3&gt;

&lt;p&gt;利用 &lt;code&gt;mdadm&lt;/code&gt; 命令创建 RAID&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~# mdadm --create --auto=yes /dev/raid0 --level=5 --raid-devices=4 --spare-devices=1 /dev/sda{5,6,7,8,9}
mdadm: /dev/raid0 is an invalid name for an md device.  Try /dev/md/raid0
root@ubuntu:~# mdadm --create --auto=yes /dev/md0 --level=5 --raid-devices=4 --spare-devices=1 /dev/sda{5,6,7,8,9} 
mdadm: Defaulting to version 1.2 metadata
mdadm: array /dev/md0 started.
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;--create&lt;/code&gt; 表示创建 RAID。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;--auto=yes&lt;/code&gt; 后面接上创建的 raid 设备的名字，第一次创建时使用了 &lt;code&gt;/dev/raid0&lt;/code&gt; 失败了，是因为必须使用md开头的命名规范。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;--raid-devices=N&lt;/code&gt; 表示使用多少个磁盘或者分区作为raid设备。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;--spare-devices=N1&lt;/code&gt; 表示使用多少个磁盘或者分区作为预备分区。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;--level=N&lt;/code&gt; 表示创建哪一种级别的raid&lt;/li&gt;
  &lt;li&gt;创建 raid 时，后面接上 &lt;code&gt;/dev/sdaX&lt;/code&gt; 表示哪些磁盘或者分区参加创建 raid ，注意了，这些磁盘或者分区的数量一定要和 raid-devices 加上 spare-devices 的值相等。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;查看创建完成的 RAID 设备信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~# mdadm --detail /dev/md0
/dev/md0:
Number   Major   Minor   RaidDevice State
0       8        5        0      active sync   /dev/sda5
1       8        6        1      active sync   /dev/sda6
2       8        7        2      active sync   /dev/sda7
5       8        8        3      active sync   /dev/sda8

4       8        9        -      spare   /dev/sda9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看最后几行，发现 &lt;code&gt;/dev/sda{5 - 8}&lt;/code&gt; 已经成为了 RAID 设备，&lt;code&gt;/dev/sda9&lt;/code&gt; 是预备的设备。&lt;/p&gt;

&lt;p&gt;补充一下，还可以通过 &lt;code&gt;cat /proc/mdstat&lt;/code&gt; 命令查看 RAID 设备信息。&lt;/p&gt;

&lt;h3 id=&quot;raid-2&quot;&gt;格式化并挂载 RAID&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~# mkfs -t ext4 /dev/md0
root@ubuntu:~# mkdir /mnt/raid
root@ubuntu:~# mount /dev/md0 /mnt/raid
root@ubuntu:~# df
Filesystem     1K-blocks     Used Available Use% Mounted on
/dev/sda2       19091584 16613668   1485048  92% /
/dev/sda1         973952     3540    970412   1% /boot/efi
/dev/sda4       86414720 75005600   6996448  92% /home
/dev/md0         3027728     4608   2849604   1% /mnt/raid
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;software-raid-&quot;&gt;利用 Software RAID 处理数据损毁&lt;/h1&gt;

&lt;p&gt;先向 &lt;code&gt;/mnt/raid&lt;/code&gt; 中添加一些数据，然后模拟 &lt;code&gt;/dev/sda8&lt;/code&gt; 的出错状态&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~# cp -a /etc /mnt/raid
root@ubuntu:~# mdadm --manage /dev/md0 --fail /dev/sda8
mdadm: set /dev/sda8 faulty in /dev/md0
root@ubuntu:~# mdadm --detail /dev/md0
Number   Major   Minor   RaidDevice State
0       8        5        0      active sync   /dev/sda5
1       8        6        1      active sync   /dev/sda6
2       8        7        2      active sync   /dev/sda7
4       8        9        3      active sync   /dev/sda9

5       8        8        -      faulty   /dev/sda8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看可发现 /dev/sda8 确实被设置出现了错误状态，接下来我将出现错误的磁盘从 RAID 中移除，并添加一块新的磁盘，在这里新的磁盘是 &lt;code&gt;/dev/sda10&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~# mdadm --manage /dev/md0 --add /dev/sda10 --remove /dev/sda8
root@ubuntu:~# mdadm --detail
Number   Major   Minor   RaidDevice State
0       8        5        0      active sync   /dev/sda5
1       8        6        1      active sync   /dev/sda6
2       8        7        2      active sync   /dev/sda7
4       8        9        3      active sync   /dev/sda9

6       8       10        -      spare   /dev/sda10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到 &lt;code&gt;/dev/sda8&lt;/code&gt; 已经被替换，而 &lt;code&gt;/dev/sda10&lt;/code&gt; 出现在预留磁盘的位置，可以查看一下 RAID 里面的数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~# du -sm /mnt/raid/*
17		/mnt/raid/etc
1		/mnt/raid/lost+found
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现数据完好。&lt;/p&gt;

&lt;h1 id=&quot;raid-3&quot;&gt;设置开机挂载 RAID&lt;/h1&gt;

&lt;p&gt;获取 RAID 设备的 uuid号码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~# mdadm --detail | grep -i uuid
UUID : 0a861ec3:399accad:00927385:a9c784c1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将设备号写入配置文件，供系统在挂载 RAID 设备的时候读取&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~# vim /etc/mdadm.conf
ARRAY /dev/md0 UUID=0a861ec3:399accad:00927385:a9c784c1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑 &lt;code&gt;/etc/fstab&lt;/code&gt; 进行开机挂载&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~# vim /etc/fstab
/dev/md0 /mnt/raid ext4 defaults 1 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重新挂载&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~# umount /dev/md0 ; mount -a
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;software-raid-2&quot;&gt;关闭 Software RAID&lt;/h1&gt;

&lt;p&gt;如何在你不想使用 Software RAID 的时候关闭 RAID，其实很简单，只要将你之前创建的各种配置文件删除即可，有一下几步：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 卸载 /dev/md0
2. 删除 `/etc/fstab` 中的记录
3. 通过 `mdadm --stop /dev/md0` 停止 RAID 服务
4. 删除 `/etc/mdadm.conf` 中的uid记录
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完。&lt;/p&gt;
</description>
        <pubDate>Wed, 14 Jun 2017 14:27:37 +0800</pubDate>
        <link>http://stormphoenix.github.com/2017/06/14/%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8%E8%BD%AF%E4%BB%B6%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97/</link>
        <guid isPermaLink="true">http://stormphoenix.github.com/2017/06/14/%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8%E8%BD%AF%E4%BB%B6%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97/</guid>
        
        <category>Linux</category>
        
        <category>RAID</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>使用Quota</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;注意事项&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;相关名词概念&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#quota&quot; id=&quot;markdown-toc-quota&quot;&gt;设置文件系统支持Quota&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#quota-1&quot; id=&quot;markdown-toc-quota-1&quot;&gt;创建Quota配置文件&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#quota-2&quot; id=&quot;markdown-toc-quota-2&quot;&gt;使用Quota&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#quota-3&quot; id=&quot;markdown-toc-quota-3&quot;&gt;生成Quota报表&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;其他&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Quota翻译成中文就是“限额”的意思，在Linux中Quota用来对用户（或用户组）的磁盘用量进行管理，这种管理在多用户的Linux系统上是很有必要的。假设有这样一种情况，好多个用户同时在主机上工作，其中一个用户无加限制的使用了很大的磁盘空间，这样就导致了其他用户可用的磁盘空间变小了，所以我们必须要对这个用户做一些磁盘容量的使用限制。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;注意事项&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Quota和ACL一样需要内核的支持，一样是针对整个文件系统而言的。所谓的针对整个文件系统，意思是假设你将&lt;code&gt;/dev/sda2&lt;/code&gt;挂载了&lt;code&gt;/home&lt;/code&gt;目录下并设置Quota，那么受影响的只是&lt;code&gt;/home&lt;/code&gt;下面所有的目录，其他目录是不会受影响的。还有一点，Quota一般是默认打开的，如果没有那就需要手动打开Quota哟。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Quota只针对普通用户有效，对root无效&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section-1&quot;&gt;相关名词概念&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;容量限制&lt;br /&gt;
  容量限制包括block限制和inode限制。通过设置block值的大小可以限制用户能够使用的最大磁盘容量，而设置inode值的大小限制了用户能够创建的最大文件数量&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;soft/hard&lt;br /&gt;
  soft限制（软限制）指明了用使用量超过多少时向用户发出警告，hard限制（硬限制）指明用户最多能使用多少用量，一旦超过就解除用户对磁盘的使用权（无法新增文件）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;grace time&lt;br /&gt;
  grace time（宽限时间）表示一个倒数时间，当用户的使用量处于soft和hard设置的值之间时，就会启动倒计时，如果超过了这个倒计时用户的磁盘使用量还处于soft和hard之间的话，用户的磁盘使用权就会锁住（无法新增文件）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;quota&quot;&gt;设置文件系统支持Quota&lt;/h1&gt;
&lt;p&gt;一般ext2、ext3和ext4都是能够支持Quota的。我们可以通过如下命令设置立即支持Quota。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~#mount -o remount, usrquota,grpquota /home
root@ubuntu:~#mount | grep home
/dev/sda4 on /home type ext4 (rw,relatime,quota,usrquota,grpquota,data=ordered)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有几点要注意&lt;br /&gt;
1. 只有root能够使用这个功能。&lt;br /&gt;
2. 此处用 &lt;code&gt;/home&lt;/code&gt; 目录做实验是因为/home恰好是挂载点。&lt;br /&gt;
3. usrquota是对单个用户做限制，grpquota是对一个组做限制。&lt;br /&gt;
4. 输出中的括号如果含有usrquota和grpquota，则证明该文件系统已经支持了quota。&lt;br /&gt;
5. 输出的信息其实存储在 &lt;code&gt;/etc/mtab&lt;/code&gt; 文件中。之前 &lt;code&gt;mount -o remount,usrquota,grpquota /home&lt;/code&gt; 其实是对文件系统进行了设置，这个设置会被保存在 &lt;code&gt;/etc/mtab&lt;/code&gt;文件中&lt;/p&gt;

&lt;p&gt;以上的命令只在此次开机中有效，如果想让系统在每次开机中都能够支持quota，则需要在/etc/fstab中添加如下语句&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LABEL=/home    /home    ext4    default,usrquota,grpquota 1 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在第四个字段的default后面加上usrquota，grpquota即可。&lt;/p&gt;

&lt;h1 id=&quot;quota-1&quot;&gt;创建Quota配置文件&lt;/h1&gt;
&lt;p&gt;有了文件系统支持quota还不够，还需要创建quota的配置文件，那么这个配置文件的作用就是用来保存不同的用户在此文件系统中已经使用的磁盘容量、容量使用限制等信息。&lt;/p&gt;

&lt;p&gt;那么quota具体是怎么工作的呢？在没有配置文件的时候，quota会扫描整个文件系统，查询每个用户（或用户组）拥有的文件总数和总大小，将查询到的信息记录到这个文件系统的根目录的配置文件之中。然后根据配置文件中对每个用户（或用户组）的限制信息来规定磁盘使用限制。&lt;/p&gt;

&lt;p&gt;也就是说，这个配置文件不是我们手动创建的，而是quota自己扫描整个文件系统信息然后创建的（因为你怎么知道不同的用户或者用户组使用了多少磁盘容量。。）。&lt;/p&gt;

&lt;p&gt;所以quotacheck命令是用来扫描这个磁盘，并在文件系统根目录创建配置文件的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~#quotacheck -augv -mf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;值得一提的是-mf两个选项，作用是强制扫描整个文件系统。因为某些时候会有其他程序在对文件系统进行读写，所以quotacheck查询出的文件数量可能是不准确的，系统会拒绝执行quotachec。不妥加上-mf参数就可以强制执行了，其他参数的含义不表。&lt;/p&gt;

&lt;p&gt;quotacheck命令先话一段时间扫描整个文件系统，执行完毕后会在/home目录下生成两个文件aquota.group和aquota.user两个文件，分别是针对用户组和用户的配置文件。&lt;/p&gt;

&lt;h1 id=&quot;quota-2&quot;&gt;使用Quota&lt;/h1&gt;

&lt;p&gt;开启Quota服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~#quotaon -avug
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关闭Quota服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~#quotaoff -a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑具体的限制值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;edquota -u [username] -g [groupname] -t
说明：
-u 对某一个用户进行编辑，后面接上用户名
-g 对某一个用户组进行编辑，后面接上用户组组名字
-t 设置宽限时间
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;样例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~#edquota -u stormphoenix
Disk quotas for user StormPhoenix (uid 1001):
Filesystem	blocks	    soft	hard    inodes      soft hard
/dev/sda4	60331452	0	    0	    1029831     0    0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分为7列，具体说明：&lt;br /&gt;
1. 具体的限制值是针对哪一个文件系统&lt;br /&gt;
2. 当前用户已经使用的磁盘容量&lt;br /&gt;
3. 当前用户使用磁盘容量的软限制值&lt;br /&gt;
4. 当前用户使用磁盘容量的硬限制值&lt;br /&gt;
5. 当前用户创建的文件数量&lt;br /&gt;
6. 当前用户穿件文件数量的软限制值&lt;br /&gt;
7. 当前用户创建文件数量的硬限制值&lt;/p&gt;

&lt;h1 id=&quot;quota-3&quot;&gt;生成Quota报表&lt;/h1&gt;
&lt;p&gt;简单的说就是查看用户或者用户组当前的使用量和限制量。&lt;/p&gt;

&lt;p&gt;查看某一个用户报表&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;quota -uvs StormPhoenix
Disk quotes for user Developer (uid 1001):
Filesystem		space		quota		limit		grace		files		quota		limit		grace
/dev/sda4		58918M		0K			0K						1030K		0			0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看某一个用户组报表同上，不同的是命令参数是 -gvs。&lt;/p&gt;

&lt;p&gt;查看某一个文件系统的限额报表。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~#repquota -auvs
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-2&quot;&gt;其他&lt;/h1&gt;
&lt;p&gt;介绍两个命令&lt;/p&gt;

&lt;p&gt;&lt;code&gt;warnquota&lt;/code&gt;用来对超出使用限制的用户发出警告，一般是用邮件发送。具体的发送信息是根据 &lt;code&gt;/etc/warnquota&lt;/code&gt; 的内容设置的。&lt;code&gt;warnquota&lt;/code&gt; 不会自动触发，需要手动启动，只要使用量处于soft和hard之间就会收到此警告（不过使用量到达了hard，就不会收到此消息了，因为用户的磁盘使用已经被剥夺，无法继续收信了）。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;setquota&lt;/code&gt; 可以直接在命令行中设置限额，用法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~#setquota [-u|-g] [name] block(soft) block(hard) inode(soft) inode(hard) [filesystem]
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Mon, 12 Jun 2017 22:49:35 +0800</pubDate>
        <link>http://stormphoenix.github.com/2017/06/12/%E4%BD%BF%E7%94%A8Quota/</link>
        <guid isPermaLink="true">http://stormphoenix.github.com/2017/06/12/%E4%BD%BF%E7%94%A8Quota/</guid>
        
        <category>Linux</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>ACL的使用</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#acl&quot; id=&quot;markdown-toc-acl&quot;&gt;启动ACL支持&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#acl-1&quot; id=&quot;markdown-toc-acl-1&quot;&gt;设置ACL&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ACL全称访问控制列表（Access Controll List），用于提供owner，group，others的rwx以外的权限。ACL可以针对某一份文件、某一个用户和用户组来设置对文件的访问控制。&lt;/p&gt;

&lt;h1 id=&quot;acl&quot;&gt;启动ACL支持&lt;/h1&gt;

&lt;p&gt;ACL需要文件系统支持，所以需要查看自己的系统是否支持ACL。我们可以通过“fdisk -l”命令来查询文件系统挂载到了哪些磁盘分区中。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/Screenshot from 2017-06-10 19-31-56.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从图中可以看到有sda2和sda4两个磁盘分区挂载了文件系统。以&lt;code&gt;sda2&lt;/code&gt;为例子，用&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dumpe2fs -h /dev/sda2 | grep acl&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;命令去查询这个文件系统是否支持acl。只要有如下的acl出现，就证明系统启动了ACL支持。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/Screenshot from 2017-06-10 19-43-52.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;acl-1&quot;&gt;设置ACL&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;setfacl&lt;/code&gt; 用于设置针对某一个文件或某一个用户的acl属性。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;-m : 选项用于给文件添加某一个acl属性。例如：setfacl -m u:用户名称:权限 文件名字。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;-b：删除文件的所有acl属性。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/Screenshot from 2017-06-10 17-05-52.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;getfacl&lt;/code&gt; 查看某一个文件的acl属性。例如：getfacl testfile。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/Screenshot from 2017-06-10 16-27-38.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;mask&lt;/code&gt;说明。使用&lt;code&gt;getfacl&lt;/code&gt;命令的时候，会看到&lt;code&gt;mask&lt;/code&gt;这个字段。&lt;code&gt;mask&lt;/code&gt;代表在设置acl的时候，用户和用户组的权限范围不得超过&lt;code&gt;mask&lt;/code&gt;的设置值。例如如果user1针对文件test的acl属性是rwx，但是test的&lt;code&gt;mask&lt;/code&gt;字段设置为r–，由于user1的权限范围不超过mask设置的值，所以user1针对test文件只具有r–的权限。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 10 Jun 2017 16:07:39 +0800</pubDate>
        <link>http://stormphoenix.github.com/2017/06/10/ACL%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
        <guid isPermaLink="true">http://stormphoenix.github.com/2017/06/10/ACL%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
        
        <category>Linux</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>Linux账号管理</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#uidgid&quot; id=&quot;markdown-toc-uidgid&quot;&gt;&lt;strong&gt;用户标识符UID与GID&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;&lt;strong&gt;相关文件结构&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;&lt;strong&gt;有效用户组和初始用户组&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;&lt;strong&gt;账号管理&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;uidgid&quot;&gt;&lt;strong&gt;用户标识符UID与GID&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;uid：用户的的id，用一个数字标志。&lt;/li&gt;
  &lt;li&gt;gid：用户所在组的id，用一个数值标志。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;&lt;strong&gt;相关文件结构&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;/etc/passwd文件结构&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;保存了系统中所有账号的信息，每一行都代表一个账号。账号的种类分为两个：&lt;code&gt;系统账号&lt;/code&gt;和&lt;code&gt;用户账号&lt;/code&gt;。其中系统账号是系统正常运行必须的。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;root:x:0:0:root:/root:/bin/bash&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;实例中的一行包括7列，用冒号“：”间隔分别说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 账号名称 

2. 账号密码，为了账号的安全性，账号的密码被保存在了/etc/shadow文件中，所以此处的密码变成了x

3. UID

4. GID

5. 用户信息说明，无重要用途

6. 主文件夹

7. Shell用户登录系统后取得的默认的shell
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;/etc/shadow文件结构&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;root:$6$qE8d/k2K$NpCCL0kCsQdpAO5pC4QD91YAKpTS8w6.qdhl/fgZurM/2npI2bvEYY.LDNtll/Jnqlq1GH.AH3Z8hGiKJgIfy.:17111:0:99999:7:::&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;提前说明三个概念：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;密码过期&lt;/strong&gt;：指超过了密码必须被修改的截止时间依然没有修改密码。在此情况下，用户依然可以使用此账号，但是账号登录的时候，系统会强制要求用户必须重新设置密码才能继续使用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;密码失效&lt;/strong&gt;：指的是密码过期超过了一定的天数，用户就无法使用此密码登录了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;账号失效&lt;/strong&gt;：账号无法使用了&lt;/p&gt;

&lt;p&gt;实例中的一行包括9列：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.账号名称

2.账号密码，不过已经被加密过了。由于固定的编码系统产生的密码长度必须一致，所以这个字段的长度改变之后，密码就会失效

3.最近更改密码的日期，这个时间是以1970年1月1日为1而累加得到的

4.密码被修改后必须过几天才能再修改

5.密码被更改后必须在多少天内再被修改

6.在密码过期前的多少天之内提醒用户密码快到期了

7.密码过期后的宽限时间，如果超过了这个时间，会发生密码失效

8.账号在过了规定的日期就会无法使用，这个时间的设置同3

9.保留字段
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;/etc/group文件结构&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;root:x:0:root&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;实例中的一行包括4列：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.用户组名字

2.用户组密码，给用户组管理员使用

3.GID

4.用户组支持的用户
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;/etc/gshadow文件结构&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;root:x:0:root&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;实例中的一行包括4列：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.用户组名字。

2.密码列，同/etc/shadow。不过如果密码列上面是!的话，代表此用户组没有管理员。

3.用户组管理员账号。

4.用户组成员，成员之间用逗号分隔开
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;&lt;strong&gt;有效用户组和初始用户组&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在/etc/passwd文件中，第四列就是用户的初始用户组组号GID，表示用户一登录系统就会取得该用户组的权限。而有效用户组是什么呢？当你登录shell，输入groups命令将会返回你所加入的所有用户组，其中第一个显示的用户组就是有效用户组。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当用户新建一个文件的时候，文件所属的用户组是创建者当前的有效用户组。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;newgrp命令可以切换当前用户的有效用户组，不过这个命令将会重新启动一个shell。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;&lt;strong&gt;账号管理&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;useradd 添加一个用户&lt;/li&gt;
  &lt;li&gt;passwd 修改用户的密码&lt;/li&gt;
  &lt;li&gt;chage 修改密码的时间设置&lt;/li&gt;
  &lt;li&gt;usermod 修改用户的信息&lt;/li&gt;
  &lt;li&gt;finger 查看当前登录用户的详细信息&lt;/li&gt;
  &lt;li&gt;chfn 修改个人信息&lt;/li&gt;
  &lt;li&gt;id 查看用户的uid和gid&lt;/li&gt;
  &lt;li&gt;groupadd 添加组&lt;/li&gt;
  &lt;li&gt;groupmod 修改group的相关参数&lt;/li&gt;
  &lt;li&gt;groupdel 删除用户组&lt;/li&gt;
  &lt;li&gt;gpasswd 用户组管理员功能&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 10 Jun 2017 13:05:30 +0800</pubDate>
        <link>http://stormphoenix.github.com/2017/06/10/Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/</link>
        <guid isPermaLink="true">http://stormphoenix.github.com/2017/06/10/Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/</guid>
        
        <category>Linux</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>Linux文件操作</title>
        <description>
&lt;p&gt;记录一下几天前学习的Linux文件和目录操作的知识。&lt;/p&gt;

&lt;p&gt;cd： 切换目录&lt;/p&gt;

&lt;p&gt;pwd：显示当前目录的路径，-p参数用于显示当前的路径，而不是显示连接路径&lt;/p&gt;

&lt;p&gt;mkdir：新建一个新的目录。&lt;/p&gt;

&lt;p&gt;rmdir：删除一个空的目录。&lt;br /&gt;
其中，mkdir每次只能创建一级目录。比如：mkdir test 将会创建一个test目录。如果想要创建多级目录，类似与dir1/dir2/dir3，就必须加上-p参数，如下：&lt;/p&gt;

&lt;p&gt;# mkdir -p dir1/dir2/dir3&lt;br /&gt;
创建目录的同时还可以加上 -m 参数来指定目录的权限（关于权限以后会有详细讲解）。&lt;/p&gt;

&lt;p&gt;# mkdir -m 711 test&lt;br /&gt;
 # ls -l&lt;br /&gt;
drwx–x–x 2 root root 4096 9月 27 10:32 test&lt;br /&gt;
关于rmdir也差不多，每次只能删除一级目录且该目录必须为空。要删除多级目录就要加上参数 -p。如果要删除目录和目录里面所有的东西（包括文件），那么可以采用 rm -r &lt;目录名称&gt;。&lt;/目录名称&gt;&lt;/p&gt;

&lt;p&gt;查看文件与目录的命令：&lt;/p&gt;

&lt;p&gt;ls:用于查看文件或目录的详细信息。&lt;br /&gt;
几个常用的参数说明：&lt;br /&gt;
-a : 显示目录下全部的文件&lt;br /&gt;
-d : 只查看目录本身，而无需列举出目录内的文件数据。&lt;br /&gt;
-h : 将文件的容量用GB，MB，KB等方式列出（方便理解）。&lt;br /&gt;
-i : 列出inode号码。&lt;br /&gt;
-l : 列出文件的属性和权限信息。&lt;br /&gt;
–time=&lt;值&gt; : 输出相应的时间。如果值等于atime，输出该文件上一次被访问的时间，如果值等于ctime，输出该文件上一次权限被修改的时间。
--full-time : 以年、月、日、时、分的格式输出时间。
复制文件的命令：&lt;/值&gt;&lt;/p&gt;

&lt;p&gt;cp: 复制文件&lt;br /&gt;
用法：cp source（源文件） destination（目标文件）//将source复制到destination里面&lt;br /&gt;
相关参数：&lt;br /&gt;
-p: 连同权限的属性一起复制过去。&lt;br /&gt;
-s: 生成一个文件，使得该文件是源文件的快捷方式。&lt;br /&gt;
删除文件的命令：&lt;/p&gt;

&lt;p&gt;rm: 删除文件&lt;br /&gt;
用法: rm source（被删除的文件名）&lt;br /&gt;
相关参数:&lt;br /&gt;
-r: 如果被删除的目录中有文件，那么一并删除该目录和里面的文件。如果不加上-r参数，那么rm只能删除单一文件或空目录。&lt;br /&gt;
移动文件的命令：&lt;/p&gt;

&lt;p&gt;mv: 移动文件&lt;br /&gt;
用法: mv source （源文件） destination （目的地）&lt;br /&gt;
相关参数:&lt;br /&gt;
-u: 若目的地文件已经存在，且源文件较新，才会移动并覆盖目的地文件。&lt;br /&gt;
-i: 若目的地文件已经存在，就会询问是否覆盖目的地文件。&lt;br /&gt;
获取文件的完整名字:&lt;/p&gt;

&lt;p&gt;basename: 获取完整名字&lt;br /&gt;
用法：basename path （获取路径下的文件名称）&lt;br /&gt;
示例: &lt;br /&gt;
 # basename /bin/mv&lt;br /&gt;
mv&lt;br /&gt;
获取文件的目录名称:&lt;/p&gt;

&lt;p&gt;dirname:&lt;br /&gt;
用法: 和basename类似。&lt;br /&gt;
示例:&lt;br /&gt;
 # dirname /bin/mv&lt;br /&gt;
/bin&lt;br /&gt;
文件内容查询命令:&lt;/p&gt;

&lt;p&gt;cat:&lt;br /&gt;
用法： cat 文件路径&lt;br /&gt;
相关参数： &lt;br /&gt;
-n：打印行号。&lt;/p&gt;

&lt;p&gt;tac：&lt;br /&gt;
用法： 类似与cat，只不过将文件内容反向输出。&lt;/p&gt;

&lt;p&gt;more：&lt;br /&gt;
用法： 类似与cat。但是不会一口气将文件内容在屏幕上输出，而是一页一页的查看。&lt;br /&gt;
相关操作&lt;br /&gt;
Enter： 查看下一行。&lt;br /&gt;
Space空格键： 查看下一页。&lt;/p&gt;

&lt;p&gt;less： 类似与cat，效果和more一样，不过可以通过page down和page up向下或者向下翻页。&lt;br /&gt;
相关操作： &lt;br /&gt;
page Down： 向下翻页。&lt;br /&gt;
page Up： 向上翻页。&lt;/p&gt;

&lt;p&gt;head：&lt;br /&gt;
用法： 类似与cat，但是只会取出前n行数据，具体的n又参数制定。&lt;br /&gt;
参数： &lt;br /&gt;
-n &lt;数字&gt;： 代表去取前n行数据。&lt;/数字&gt;&lt;/p&gt;

&lt;p&gt;tail： &lt;br /&gt;
用法： 同head，只不过取得是文件末尾n行数据。&lt;/p&gt;

&lt;p&gt;od：&lt;br /&gt;
用法： 以特定的方式来读取文件，方式是 cd [-t TYPE] 文件路径，具体看下面。&lt;br /&gt;
相关参数： &lt;br /&gt;
-t： 以某种方式读取文件内容，-t后面也会接上参数，他有如下参数： &lt;br /&gt;
    a： 默认字符来输出。&lt;br /&gt;
    c： 利用ASCII来输出。&lt;br /&gt;
    d[size]： 利用十进制输出，每个数字占用size个bytes。&lt;br /&gt;
    o[size]： 利用八进制输出，其他同d。&lt;br /&gt;
    f[size]： 摸底，其他同d。&lt;br /&gt;
    x[size]： 利用十六进制输出，其他同d。&lt;br /&gt;
修改/创建文件命令touch&lt;/p&gt;

&lt;p&gt;先介绍和文件相关的几个时间概念：&lt;/p&gt;

&lt;p&gt;modification time （mtime）：当文件内容改变时，mtime会被修改成文件内容变动时的时间。&lt;/p&gt;

&lt;p&gt;status time （ctime）：当文件的权限和属性变动时，ctime会被修改成属性变动的时间。&lt;/p&gt;

&lt;p&gt;access time （atime）：当文件被人访问时，atime会被修改成别人当时访问的时间。&lt;/p&gt;

&lt;p&gt;touch使用的格式： touch [参数] 文件名。&lt;/p&gt;

&lt;p&gt;具体如下&lt;/p&gt;

&lt;p&gt;新建一个空文件：&lt;/p&gt;

&lt;p&gt;# touch test&lt;br /&gt;
 # ls -l test&lt;br /&gt;
-rw-r–r– 1 root root 0 9月 29 19:28 test&lt;br /&gt;
/×此时test文件的三个时间就会更新为当前的时间×/&lt;br /&gt;
修改文件的时间&lt;/p&gt;

&lt;p&gt;# touch -t 0710250213 test&lt;br /&gt;
 # ll test; ll –time=atime test; ll –time=ctime test&lt;br /&gt;
-rw-rw-r– 1 root root 0 10月 25 2007 test&lt;br /&gt;
-rw-rw-r– 1 root root 0 10月 25 2007 test&lt;br /&gt;
-rw-rw-r– 1 root root 0 9月 29 20:29 test&lt;br /&gt;
/&lt;em&gt;如果没有添加–time参数，则默认输出mtime&lt;/em&gt;/&lt;br /&gt;
touch创建目录时默认的权限&lt;/p&gt;

&lt;p&gt;先谈一谈 umask&lt;/p&gt;

&lt;p&gt;在终端内输入如下语句，打印unmask的值。&lt;/p&gt;

&lt;p&gt;# umask&lt;br /&gt;
0022&lt;br /&gt;
在分别打印文件所有者、组员、其他人的默认权限&lt;/p&gt;

&lt;p&gt;# umask -S&lt;br /&gt;
u=rwx,g=rx,o=rx&lt;br /&gt;
做一下解释，当用户创建一个文件时，这个文件的权限时怎么确定的。&lt;/p&gt;

&lt;p&gt;首先来看创建文件，文件默认没有可执行权限（x），只有（r）（w）权限，所以默认权限为-rw-rw-rw-，化成数字就是666。那么最终权限的确定就是由这个数字666减去umask的后三位，也就是022，得到644，变换成字符表示就这样的：-rw-r–r–。&lt;/p&gt;

&lt;p&gt;再来看创建文件夹。由于（x）权限与是否可以进入此文件夹有关，所以文件夹的（x）权限默认开放，也就是drwxrwxrwx，化成数字777。然后777减去umask的后三位，得到755，也就是drwxr-xr-x。&lt;/p&gt;

&lt;p&gt;所以说创建文件或者文件夹时的默认权限和unmask有关，修改默认的权限就是修改umask，修改方法如下：&lt;/p&gt;

&lt;p&gt;# umask 044 //修改来unmask，然后来看看默认权限是否改变&lt;br /&gt;
 # touch test&lt;br /&gt;
 # mkdir test2&lt;br /&gt;
-rw–w–w- 1 root root 0 9月 29 21:14 test&lt;br /&gt;
drwx-wx-wx 2 root root 4096 9月 29 21:14 test1&lt;br /&gt;
（对于权限不理解的，可以看看我写的关于权限的文章。）&lt;/p&gt;

&lt;p&gt;文件的隐藏属性&lt;/p&gt;

&lt;p&gt;文件的隐藏属性主要时和文件安全相关系的，比如某些属性可以使得文件无法被删除，有些使得文件只能被添加数据等。&lt;/p&gt;

&lt;p&gt;那么对这些隐藏属性进行操作的命令就是：&lt;/p&gt;

&lt;p&gt;chattr：修改文件隐藏属性。 &lt;br /&gt;
lsattr：列举出文件的隐藏属性。&lt;/p&gt;

&lt;p&gt;举个例子：&lt;/p&gt;

&lt;p&gt;# chattr +i test&lt;br /&gt;
这个命令使得test这个文件加上来不可被其他人修改、删除的属性。&lt;/p&gt;

&lt;p&gt;再来一个：&lt;/p&gt;

&lt;p&gt;# chattr -i test&lt;br /&gt;
这样就使得test文件剔除了i属性，也就是说test这个文件可以被其他人修改或删除了。&lt;/p&gt;

&lt;p&gt;下面是相关的属性列表：&lt;/p&gt;

&lt;p&gt;+：增加一个属性。&lt;br /&gt;
-：剔除一个属性。&lt;br /&gt;
a：让文件只能被添加数据，而不能被删除或修改数据，只有root能够设置该属性。&lt;br /&gt;
i：任何人都不能对该。文件做任何修改（添加、删除等）&lt;br /&gt;
其他的自行man。&lt;/p&gt;

&lt;p&gt;查找可执行文件(.sh)的路径&lt;/p&gt;

&lt;p&gt;which：查找某一个可执行文件的完整路径。它的原理时是搜索PATH路径下的后缀为（.sh）的文件。&lt;/p&gt;

&lt;p&gt;参数：&lt;br /&gt;
-a：将可以找到的所有可执行命令路径全部列出。&lt;br /&gt;
示例：&lt;br /&gt;
 # which ls&lt;br /&gt;
 # /bin/ls&lt;br /&gt;
查找普通文件的路径&lt;/p&gt;

&lt;p&gt;whereis：该命令用于查找一般的文件，查找的原理是利用数据库来查找数据，并没有查询整个磁盘。再说find命令，它才是通过整个磁盘来查询文件的。&lt;/p&gt;

&lt;p&gt;所以说有的命令文件没有被加入PATH，但却被存储进数据库里面，所以whereis有时候会找到which找不到的文件。&lt;/p&gt;

&lt;p&gt;参数：&lt;br /&gt;
-b：只找二进制的文件。&lt;br /&gt;
-m：找到man文件路径下的文件。&lt;br /&gt;
-s：只找source源文件。&lt;br /&gt;
-u：查找不是上面三个选项的其他特殊文件。&lt;br /&gt;
locate：locate是这样用的，只要文件名/路径名包含你要查找的字符串，那么就会将文件名/路径名显示出来。（locate也是通过查询数据库来输出结果）&lt;/p&gt;

&lt;p&gt;参数：&lt;br /&gt;
-i：忽略大小写的差异。&lt;br /&gt;
-r：在后面介入正则表达式。&lt;br /&gt;
示例：&lt;br /&gt;
 # locate ls&lt;br /&gt;
 # …….&lt;br /&gt;
//包含ls字符串的文件名/路径名太多，所以用…代替&lt;br /&gt;
find：直接在整个磁盘搜索相关文件名。&lt;/p&gt;

&lt;p&gt;有好几种用法，且听我一一道来。&lt;/p&gt;

&lt;p&gt;用法1：将路径下所有符合时间条件的文件全部列出来。&lt;/p&gt;

&lt;p&gt;find &lt;在什么路径下搜索&gt; &lt;按照什么条件搜索&gt; &lt;搜索条件的取值&gt;
相关搜索条件：&lt;按照什么条件搜索&gt; &lt;搜索条件的取值&gt;
-mtime +n：搜索在n天之前（不包含第n天）修改过的文件。
-mtime n：搜索在n天之前的一天之内被更改的文件。
-mtime -n：搜索在n天之内（包含n天）被更改过的文件。
-newer file :file是一个文件，这个条件的含义是搜索比这个file更加新的文件。&lt;/搜索条件的取值&gt;&lt;/按照什么条件搜索&gt;&lt;/搜索条件的取值&gt;&lt;/按照什么条件搜索&gt;&lt;/在什么路径下搜索&gt;&lt;/p&gt;

&lt;p&gt;用法2：将路径下所有符合文件所有者、所有组和其他人权限的文件列出来。&lt;/p&gt;

&lt;p&gt;find &lt;在什么路径下搜索&gt; &lt;搜索条件&gt; &lt;搜索条件的取值&gt;
相关搜索条件：
-uid n：n代表用户帐号的ID，只要文件的所有者的id是这个n，则列出这个文件。
-gid n：n代表用户组的ID，只要文件的所有组的id是这个n，则列出这个文件。
-user name：那么是用户的名字，只要文件所有者是这个名字，则列出这个文件。
-group name：同上，这不过这个name是文件所有组的名字。
-nouser：列出文件所有者不存在的文件。
-nogroup：列出所有文件所有组不存在的文件。&lt;/搜索条件的取值&gt;&lt;/搜索条件&gt;&lt;/在什么路径下搜索&gt;&lt;/p&gt;

&lt;p&gt;用法3：将路径下符合指定的文件名、文件类型、文件权限的的文件列出来。&lt;/p&gt;

&lt;p&gt;-name filename：列出符合文件名是filename的文件。&lt;br /&gt;
-size +size：列出文件大小大于size的文件。&lt;br /&gt;
-size -size：类出文件大小小于size的文件。&lt;br /&gt;
    这个size有几个单位：&lt;br /&gt;
    c：代表byte。 &lt;br /&gt;
    k：代表KB&lt;br /&gt;
    所以1000k代表的是1MB。&lt;br /&gt;
-type type：类出文件类型是type的文件。具体的type有如下几个：&lt;br /&gt;
    f：一般文件。&lt;br /&gt;
    b，c：设备文件。 &lt;br /&gt;
    d：目录。 &lt;br /&gt;
    l：连接文件。 &lt;br /&gt;
    s：socket文件。 &lt;br /&gt;
    p：FIFO文件。 &lt;br /&gt;
-perm mode：列出文件权限是mode的文件。这个mode是一个数字，其余的可以参考Linux文件的权限。&lt;br /&gt;
-perm -mode：只要文件的权限包含了mode所指示的权限，则列出它。&lt;br /&gt;
-perm +mode：只要文件的权限包含了mode所指示的权限中任意一个，则列出这个文件。&lt;/p&gt;

&lt;p&gt;用法4：可以在find的前三种用法的基础上，在末尾添加而外的处理命令。&lt;br /&gt;
参数：&lt;br /&gt;
-exec COMMAND命令：对find查找的结果用COMMAND命令进行额外的处理。&lt;/p&gt;

&lt;p&gt;用例：&lt;br /&gt;
 # find / -mtime +4 -exec ls -al {} \;&lt;br /&gt;
//对find查找出来的结果进行ls -al命令的处理。&lt;/p&gt;

&lt;p&gt;-exec命令的具体说明：&lt;br /&gt;
其实-exec的具体格式是这样的-exec COMMAND {} ;&lt;/p&gt;

&lt;p&gt;1.其中{}存放着find命令找出来的结果，所以COMMAND {}的含义是对find命令找出来的结果执行COMMAND命令。&lt;/p&gt;

&lt;p&gt;2.那么“-exec”和“;”分别代表着分割符号，-exec是起始符号，“;”代表结束符号，那么位于这两者之间的就是需要执行的额外命令。&lt;/p&gt;

&lt;p&gt;3.“;”是命令的分割符号，有它自己特殊的意义，所以在这个地方要进行字符的转义，于是用“\;”代替“;”。&lt;/p&gt;
</description>
        <pubDate>Sat, 10 Jun 2017 12:09:39 +0800</pubDate>
        <link>http://stormphoenix.github.com/2017/06/10/Linux%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</link>
        <guid isPermaLink="true">http://stormphoenix.github.com/2017/06/10/Linux%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</guid>
        
        <category>Linux</category>
        
        
        <category>Linux</category>
        
      </item>
    
  </channel>
</rss>
